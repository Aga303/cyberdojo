# Logfile created on Sun Jan 10 22:34:50 +0000 2010

Processing DojoController#index (for 127.0.0.1 at 2010-01-10 22:34:51) [GET]
Rendering template within layouts/application
Rendering dojo/index
Completed in 24ms (View: 22, DB: 0) | 200 OK [http://localhost/]


Processing KataController#start (for 127.0.0.1 at 2010-01-10 22:34:59) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Frogs", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Frogs"}
Rendering template within layouts/application
Rendering kata/start
Completed in 187ms (View: 162, DB: 0) | 200 OK [http://localhost/kata/start]


Processing DojoController#index (for 127.0.0.1 at 2010-01-10 22:35:13) [GET]
Rendering template within layouts/application
Rendering dojo/index
Completed in 4ms (View: 4, DB: 0) | 200 OK [http://localhost/]


Processing KataController#start (for 127.0.0.1 at 2010-01-10 22:35:21) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Frogs", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Frogs"}
Rendering template within layouts/application
Rendering kata/start
Completed in 9ms (View: 7, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-10 22:35:26) [POST]
  Parameters: {"commit"=>"run-tests>", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n  /* comment */\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char * line);\n\n#endif\n\n", "avatar"=>"Frogs", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n  /* comment */\n}\n\n"}
Rendering kata/run_tests
Completed in 1261ms (View: 3, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Frogs&kata_id=99]


Processing KataController#see_all_increments (for 127.0.0.1 at 2010-01-10 22:35:29) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering kata/see_all_increments
Completed in 23ms (View: 5, DB: 0) | 200 OK [http://localhost/kata/see_all_increments/99]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-10 22:35:33) [GET]
  Parameters: {"increment"=>"19", "id"=>"99", "avatar"=>"Frogs"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 16ms (View: 7, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/99?avatar=Frogs&increment=19]


Processing KataController#help (for 127.0.0.1 at 2010-01-10 22:35:41) [GET]
Rendering template within layouts/application
Rendering kata/help
Completed in 7ms (View: 6, DB: 0) | 200 OK [http://localhost/kata/help]


Processing DojoController#index (for 127.0.0.1 at 2010-01-10 22:35:48) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 4ms (View: 4, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 10:21:59) [GET]
Rendering template within layouts/application
Rendering dojo/index
Completed in 36ms (View: 34, DB: 0) | 200 OK [http://localhost/]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 11:01:29) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Frogs", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Frogs"}
Rendering template within layouts/application
Rendering kata/start
Completed in 235ms (View: 199, DB: 0) | 200 OK [http://localhost/kata/start]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 11:05:48) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 15ms (View: 13, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 11:05:52) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Frogs", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Frogs"}
Rendering template within layouts/application
Rendering kata/start
Completed in 201ms (View: 196, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 11:05:59) [POST]
  Parameters: {"commit"=>"run-tests>", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n  /* comment */\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char * line);\n\n#endif\n\n", "avatar"=>"Frogs", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n  /* comment */\n}\n\n"}
Rendering kata/run_tests
Completed in 2336ms (View: 3, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Frogs&kata_id=99]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 11:44:17) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 15ms (View: 13, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 11:44:23) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Frogs", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Frogs"}
Rendering template within layouts/application
Rendering kata/start
Completed in 305ms (View: 301, DB: 0) | 200 OK [http://localhost/kata/start]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 11:59:18) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 32ms (View: 28, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 11:59:36) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 177ms (View: 174, DB: 0) | 200 OK [http://localhost/kata/start]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 12:03:53) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 14ms (View: 13, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 12:03:56) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 195ms (View: 192, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 12:04:03) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :visible_files=>{\"unsplice.h\"=>{}, \"notes.txt\"=>{}, \"instructions\"=>{}, \"unsplice.tests.c\"=>{}, \"run_tests_output\"=>{}, \"unsplice.c\"=>{}}, :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1080ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 12:05:49) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :visible_files=>{\"unsplice.h\"=>{}, \"notes.txt\"=>{}, \"instructions\"=>{}, \"unsplice.tests.c\"=>{}, \"run_tests_output\"=>{}, \"unsplice.c\"=>{}}, :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1204ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 12:05:59) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :visible_files=>{\"unsplice.h\"=>{}, \"notes.txt\"=>{}, \"instructions\"=>{}, \"unsplice.tests.c\"=>{}, \"run_tests_output\"=>{}, \"unsplice.c\"=>{}}, :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(cha line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(cha line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1236ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 12:06:08) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :visible_files=>{\"unsplice.h\"=>{}, \"notes.txt\"=>{}, \"instructions\"=>{}, \"unsplice.tests.c\"=>{}, \"run_tests_output\"=>{}, \"unsplice.c\"=>{}}, :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1268ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 12:06:11) [GET]
  Parameters: {"increment"=>"2", "id"=>"99", "avatar"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 5ms (View: 4, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/99?avatar=Wolves&increment=2]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 12:09:24) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 15ms (View: 13, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 12:09:27) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}

ArgumentError (wrong number of arguments (2 for 3)):
  app/models/avatar_model.rb:62:in `save'
  app/models/avatar_model.rb:62:in `locked_read_most_recent_files'
  app/models/avatar_model.rb:25:in `read_most_recent_files'
  app/models/kata_model.rb:45:in `flock'
  app/models/avatar_model.rb:24:in `read_most_recent_files'
  app/models/avatar_model.rb:23:in `open'
  app/models/avatar_model.rb:23:in `read_most_recent_files'
  app/controllers/kata_controller.rb:33:in `start'
  passenger (2.2.7) lib/phusion_passenger/rack/request_handler.rb:95:in `process_request'
  passenger (2.2.7) lib/phusion_passenger/abstract_request_handler.rb:207:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:374:in `start_request_handler'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:332:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/utils.rb:184:in `safe_fork'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:330:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:163:in `start'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:209:in `start'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:262:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:126:in `lookup_or_add'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:256:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:80:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:79:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:255:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:154:in `spawn_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:287:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'

Rendering rescues/layout (internal_server_error)


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 12:12:41) [GET]
Rendering template within layouts/application
Rendering dojo/index
Completed in 27ms (View: 25, DB: 0) | 200 OK [http://localhost/]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 12:12:52) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 195ms (View: 192, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 12:12:55) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :visible_files=>{\"unsplice.h\"=>{}, \"notes.txt\"=>{}, \"instructions\"=>{}, \"unsplice.tests.c\"=>{}, \"run_tests_output\"=>{}, \"unsplice.c\"=>{}}, :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}

ArgumentError (wrong number of arguments (3 for 2)):
  app/controllers/kata_controller.rb:62:in `save'
  app/controllers/kata_controller.rb:62:in `run_tests'
  passenger (2.2.7) lib/phusion_passenger/rack/request_handler.rb:95:in `process_request'
  passenger (2.2.7) lib/phusion_passenger/abstract_request_handler.rb:207:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:374:in `start_request_handler'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:332:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/utils.rb:184:in `safe_fork'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:330:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:163:in `start'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:209:in `start'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:262:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:126:in `lookup_or_add'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:256:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:80:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:79:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:255:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:154:in `spawn_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:287:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'

Rendering rescues/layout (internal_server_error)


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 12:26:02) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :visible_files=>{\"unsplice.h\"=>{}, \"notes.txt\"=>{}, \"instructions\"=>{}, \"unsplice.tests.c\"=>{}, \"run_tests_output\"=>{}, \"unsplice.c\"=>{}}, :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n    if (line[0] == '\\\\');\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n    if (line[0] == '\\\\');\n}\n\n"}

ArgumentError (wrong number of arguments (3 for 2)):
  app/controllers/kata_controller.rb:62:in `save'
  app/controllers/kata_controller.rb:62:in `run_tests'
  passenger (2.2.7) lib/phusion_passenger/rack/request_handler.rb:95:in `process_request'
  passenger (2.2.7) lib/phusion_passenger/abstract_request_handler.rb:207:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:374:in `start_request_handler'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:332:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/utils.rb:184:in `safe_fork'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:330:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:163:in `start'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:209:in `start'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:262:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:126:in `lookup_or_add'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:256:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:80:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:79:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:255:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:154:in `spawn_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:287:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'

Rendering rescues/layout (internal_server_error)


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 12:26:54) [GET]
Rendering template within layouts/application
Rendering dojo/index
Completed in 15ms (View: 13, DB: 0) | 200 OK [http://localhost/]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 12:26:59) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 188ms (View: 184, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 12:27:04) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :visible_files=>{\"unsplice.h\"=>{}, \"notes.txt\"=>{}, \"instructions\"=>{}, \"unsplice.tests.c\"=>{}, \"run_tests_output\"=>{}, \"unsplice.c\"=>{}}, :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1276ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 12:27:19) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :visible_files=>{\"unsplice.h\"=>{}, \"notes.txt\"=>{}, \"instructions\"=>{}, \"unsplice.tests.c\"=>{}, \"run_tests_output\"=>{}, \"unsplice.c\"=>{}}, :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n    if (line[0] == '\\\\');\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n    if (line[0] == '\\\\');\n}\n\n"}
Rendering kata/run_tests
Completed in 1295ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 12:46:28) [GET]
Rendering template within layouts/application
Rendering dojo/index
Completed in 14ms (View: 13, DB: 0) | 200 OK [http://localhost/]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 12:46:32) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 210ms (View: 206, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 12:47:17) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{}, \"notes.txt\"=>{}, \"instructions\"=>{}, \"unsplice.tests.c\"=>{}, \"run_tests_output\"=>{}, \"unsplice.c\"=>{}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);xx\n\n#endif\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);xx\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1251ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 12:49:22) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{}, \"notes.txt\"=>{}, \"instructions\"=>{}, \"unsplice.tests.c\"=>{}, \"run_tests_output\"=>{}, \"unsplice.c\"=>{}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}

NoMethodError (undefined method `[]' for nil:NilClass):
  app/models/avatar_model.rb:81:in `locked_save'
  app/models/avatar_model.rb:79:in `each'
  app/models/avatar_model.rb:79:in `locked_save'
  app/models/avatar_model.rb:35:in `save'
  app/models/kata_model.rb:45:in `flock'
  app/models/avatar_model.rb:34:in `save'
  app/models/avatar_model.rb:33:in `open'
  app/models/avatar_model.rb:33:in `save'
  app/controllers/kata_controller.rb:62:in `run_tests'
  passenger (2.2.7) lib/phusion_passenger/rack/request_handler.rb:95:in `process_request'
  passenger (2.2.7) lib/phusion_passenger/abstract_request_handler.rb:207:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:374:in `start_request_handler'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:332:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/utils.rb:184:in `safe_fork'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:330:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:163:in `start'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:209:in `start'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:262:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:126:in `lookup_or_add'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:256:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:80:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:79:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:255:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:154:in `spawn_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:287:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'

Rendering rescues/layout (internal_server_error)


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 12:51:36) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 12ms (View: 11, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 12:54:20) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 209ms (View: 205, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 13:00:00) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])xx\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])xx\n{\n}\n\n"}

NoMethodError (undefined method `[]' for nil:NilClass):
  app/models/avatar_model.rb:81:in `locked_save'
  app/models/avatar_model.rb:79:in `each'
  app/models/avatar_model.rb:79:in `locked_save'
  app/models/avatar_model.rb:35:in `save'
  app/models/kata_model.rb:45:in `flock'
  app/models/avatar_model.rb:34:in `save'
  app/models/avatar_model.rb:33:in `open'
  app/models/avatar_model.rb:33:in `save'
  app/controllers/kata_controller.rb:62:in `run_tests'
  passenger (2.2.7) lib/phusion_passenger/rack/request_handler.rb:95:in `process_request'
  passenger (2.2.7) lib/phusion_passenger/abstract_request_handler.rb:207:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:374:in `start_request_handler'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:332:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/utils.rb:184:in `safe_fork'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:330:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:163:in `start'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:209:in `start'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:262:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:126:in `lookup_or_add'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:256:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:80:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:79:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:255:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:154:in `spawn_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:287:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'

Rendering rescues/layout (internal_server_error)


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 13:04:50) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 15ms (View: 13, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 13:04:53) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 206ms (View: 200, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 13:05:00) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])xx\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])xx\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1254ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 13:15:42) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\nunsplice.c: In function 'unsplice':\nunsplice.c:3: error: expected declaration specifiers before 'xx'\nunsplice.c:5: error: expected '{' at end of input\nmake: *** [run.tests.exe] Error 1\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])xx\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1273ms (View: 10, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 13:15:50) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1203ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 13:15:57) [GET]
  Parameters: {"increment"=>"1", "id"=>"99", "avatar"=>"Wolves"}

NameError (undefined local variable or method `avatar' for #<KataController:0x7fe65833bf30>):
  app/controllers/kata_controller.rb:95:in `see_one_increment'
  passenger (2.2.7) lib/phusion_passenger/rack/request_handler.rb:95:in `process_request'
  passenger (2.2.7) lib/phusion_passenger/abstract_request_handler.rb:207:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:374:in `start_request_handler'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:332:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/utils.rb:184:in `safe_fork'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:330:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:163:in `start'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:209:in `start'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:262:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:126:in `lookup_or_add'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:256:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:80:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:79:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:255:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:154:in `spawn_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:287:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'

Rendering rescues/layout (internal_server_error)


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 13:16:45) [GET]
  Parameters: {"increment"=>"1", "id"=>"99", "avatar"=>"Wolves"}

NoMethodError (undefined method `increments' for "Wolves":String):
  app/controllers/kata_controller.rb:95:in `see_one_increment'
  passenger (2.2.7) lib/phusion_passenger/rack/request_handler.rb:95:in `process_request'
  passenger (2.2.7) lib/phusion_passenger/abstract_request_handler.rb:207:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:374:in `start_request_handler'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:332:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/utils.rb:184:in `safe_fork'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:330:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:163:in `start'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:209:in `start'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:262:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:126:in `lookup_or_add'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:256:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:80:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:79:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:255:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:154:in `spawn_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:287:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'

Rendering rescues/layout (internal_server_error)


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 13:17:29) [GET]
  Parameters: {"increment"=>"1", "id"=>"99", "avatar"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 31ms (View: 29, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/99?avatar=Wolves&increment=1]


Processing KataController#see_all_increments (for 127.0.0.1 at 2010-01-12 13:17:51) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering kata/see_all_increments
Completed in 5ms (View: 4, DB: 0) | 200 OK [http://localhost/kata/see_all_increments/99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 13:18:10) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n    line[0] = 'x';\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n    line[0] = 'x';\n}\n\n"}
Rendering kata/run_tests
Completed in 1219ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 13:19:42) [GET]
  Parameters: {"increment"=>"3", "id"=>"99", "avatar"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 6ms (View: 5, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/99?avatar=Wolves&increment=3]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 13:25:08) [GET]
  Parameters: {"increment"=>"2", "id"=>"99", "avatar"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 5ms (View: 5, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/99?avatar=Wolves&increment=2]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 13:29:02) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 7ms (View: 6, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 13:29:06) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 10ms (View: 8, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 13:31:42) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1216ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 13:39:36) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 15ms (View: 13, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 13:39:39) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 182ms (View: 178, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 13:39:46) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1260ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 13:39:59) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n    line[0] = 'X';\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n    line[0] = 'X';\n}\n\n"}
Rendering kata/run_tests
Completed in 1145ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 13:40:13) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[]);\n{\n    line[0] = 'X';\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[]);\n{\n    line[0] = 'X';\n}\n\n"}
Rendering kata/run_tests
Completed in 1269ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 13:40:17) [GET]
  Parameters: {"increment"=>"2", "id"=>"99", "avatar"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 6ms (View: 5, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/99?avatar=Wolves&increment=2]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 13:43:08) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 38ms (View: 36, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 13:43:12) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 28ms (View: 25, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 13:43:25) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{}, \"notes.txt\"=>{}, \"instructions\"=>{}, \"unsplice.tests.c\"=>{}, \"run_tests_output\"=>{}, \"unsplice.c\"=>{}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);xxxx\n\n#endif\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);xxxx\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1241ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 13:43:41) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{}, \"notes.txt\"=>{}, \"instructions\"=>{}, \"unsplice.tests.c\"=>{}, \"run_tests_output\"=>{}, \"unsplice.c\"=>{}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"xabc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"xabc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1219ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 13:43:50) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{}, \"notes.txt\"=>{}, \"instructions\"=>{}, \"unsplice.tests.c\"=>{}, \"run_tests_output\"=>{}, \"unsplice.c\"=>{}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1233ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 13:43:53) [GET]
  Parameters: {"increment"=>"1", "id"=>"99", "avatar"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 6ms (View: 5, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/99?avatar=Wolves&increment=1]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 13:44:58) [GET]
  Parameters: {"increment"=>"2", "id"=>"99", "avatar"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 6ms (View: 5, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/99?avatar=Wolves&increment=2]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 14:01:59) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 20ms (View: 19, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 14:02:03) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 198ms (View: 194, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:02:28) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1260ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:02:34) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])ss\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])ss\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1059ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#see_all_increments (for 127.0.0.1 at 2010-01-12 14:02:37) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering kata/see_all_increments
Completed in 4ms (View: 4, DB: 0) | 200 OK [http://localhost/kata/see_all_increments/99]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 14:02:45) [GET]
  Parameters: {"increment"=>"1", "id"=>"99", "avatar"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 6ms (View: 5, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/99?avatar=Wolves&increment=1]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 14:09:07) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 14ms (View: 12, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 14:09:10) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 20ms (View: 17, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:09:19) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"unsplice.c: In function 'unsplice':\\n\", \"unsplice.c:3: error: expected declaration specifiers before 'ss'\\n\", \"unsplice.c:5: error: expected '{' at end of input\\n\", \"make: *** [run.tests.exe] Error 1\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char line[])ss\\n{\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])ss\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\nunsplice.c: In function 'unsplice':\nunsplice.c:3: error: expected declaration specifiers before 'ss'\nunsplice.c:5: error: expected '{' at end of input\nmake: *** [run.tests.exe] Error 1\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])ss\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1235ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:09:28) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"unsplice.c: In function 'unsplice':\\n\", \"unsplice.c:3: error: expected declaration specifiers before 'ss'\\n\", \"unsplice.c:5: error: expected '{' at end of input\\n\", \"make: *** [run.tests.exe] Error 1\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char line[])ss\\n{\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1306ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:12:52) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"unsplice.c: In function 'unsplice':\\n\", \"unsplice.c:3: error: expected declaration specifiers before 'ss'\\n\", \"unsplice.c:5: error: expected '{' at end of input\\n\", \"make: *** [run.tests.exe] Error 1\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char line[])ss\\n{\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1207ms (View: 169, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:12:57) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"unsplice.c: In function 'unsplice':\\n\", \"unsplice.c:3: error: expected declaration specifiers before 'ss'\\n\", \"unsplice.c:5: error: expected '{' at end of input\\n\", \"make: *** [run.tests.exe] Error 1\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char line[])ss\\n{\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])ss\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])ss\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1294ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:13:12) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"unsplice.c: In function 'unsplice':\\n\", \"unsplice.c:3: error: expected declaration specifiers before 'ss'\\n\", \"unsplice.c:5: error: expected '{' at end of input\\n\", \"make: *** [run.tests.exe] Error 1\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char line[])ss\\n{\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1266ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:13:18) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"unsplice.c: In function 'unsplice':\\n\", \"unsplice.c:3: error: expected declaration specifiers before 'ss'\\n\", \"unsplice.c:5: error: expected '{' at end of input\\n\", \"make: *** [run.tests.exe] Error 1\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char line[])ss\\n{\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"xabc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"xabc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1258ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 14:13:21) [GET]
  Parameters: {"increment"=>"4", "id"=>"99", "avatar"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 9ms (View: 8, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/99?avatar=Wolves&increment=4]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 14:13:45) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 7ms (View: 5, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 14:16:20) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 9ms (View: 8, DB: 0) | 200 OK [http://localhost/kata/start]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 14:16:38) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 4ms (View: 4, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 14:21:53) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 22ms (View: 19, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:22:45) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1252ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:22:50) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])ss\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])ss\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1248ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 14:22:53) [GET]
  Parameters: {"increment"=>"1", "id"=>"99", "avatar"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 6ms (View: 5, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/99?avatar=Wolves&increment=1]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 14:24:14) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 14ms (View: 13, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 14:24:34) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 201ms (View: 198, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:24:40) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1212ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:24:46) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])ss\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])ss\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1050ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:25:01) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"xabc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"xabc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1283ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 14:25:05) [GET]
  Parameters: {"increment"=>"2", "id"=>"99", "avatar"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 6ms (View: 5, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/99?avatar=Wolves&increment=2]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 14:38:32) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 38ms (View: 36, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 14:38:35) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 15ms (View: 11, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:38:41) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}

NoMethodError (undefined method `each' for nil:NilClass):
  app/controllers/kata_controller.rb:119:in `do_run_tests'
  app/controllers/kata_controller.rb:57:in `run_tests'
  passenger (2.2.7) lib/phusion_passenger/rack/request_handler.rb:95:in `process_request'
  passenger (2.2.7) lib/phusion_passenger/abstract_request_handler.rb:207:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:374:in `start_request_handler'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:332:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/utils.rb:184:in `safe_fork'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:330:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:163:in `start'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:209:in `start'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:262:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:126:in `lookup_or_add'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:256:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:80:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:79:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:255:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:154:in `spawn_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:287:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'

Rendering rescues/layout (internal_server_error)


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:38:54) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}

NoMethodError (undefined method `each' for nil:NilClass):
  app/controllers/kata_controller.rb:119:in `do_run_tests'
  app/controllers/kata_controller.rb:57:in `run_tests'
  passenger (2.2.7) lib/phusion_passenger/rack/request_handler.rb:95:in `process_request'
  passenger (2.2.7) lib/phusion_passenger/abstract_request_handler.rb:207:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:374:in `start_request_handler'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:332:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/utils.rb:184:in `safe_fork'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:330:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:163:in `start'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:209:in `start'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:262:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:126:in `lookup_or_add'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:256:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:80:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:79:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:255:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:154:in `spawn_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:287:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'

Rendering rescues/layout (internal_server_error)


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 14:39:54) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 16ms (View: 14, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 14:39:57) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 232ms (View: 228, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:40:04) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}

NoMethodError (undefined method `each' for nil:NilClass):
  app/controllers/kata_controller.rb:119:in `do_run_tests'
  app/controllers/kata_controller.rb:57:in `run_tests'
  passenger (2.2.7) lib/phusion_passenger/rack/request_handler.rb:95:in `process_request'
  passenger (2.2.7) lib/phusion_passenger/abstract_request_handler.rb:207:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:374:in `start_request_handler'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:332:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/utils.rb:184:in `safe_fork'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:330:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:163:in `start'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:209:in `start'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:262:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:126:in `lookup_or_add'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:256:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:80:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:79:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:255:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:154:in `spawn_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:287:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'

Rendering rescues/layout (internal_server_error)


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 14:40:37) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 19ms (View: 18, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 14:40:40) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 16ms (View: 13, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:40:45) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1237ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:40:51) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])ww\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])ww\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1242ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 14:40:56) [GET]
  Parameters: {"increment"=>"1", "id"=>"99", "avatar"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 6ms (View: 5, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/99?avatar=Wolves&increment=1]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 14:41:13) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"sabc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"sabc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1300ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#see_all_increments (for 127.0.0.1 at 2010-01-12 14:41:16) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering kata/see_all_increments
Completed in 5ms (View: 4, DB: 0) | 200 OK [http://localhost/kata/see_all_increments/99]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 14:41:19) [GET]
  Parameters: {"increment"=>"3", "id"=>"99", "avatar"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 6ms (View: 5, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/99?avatar=Wolves&increment=3]


Processing KataController#help (for 127.0.0.1 at 2010-01-12 14:43:48) [GET]
Rendering template within layouts/application
Rendering kata/help

ActionView::TemplateError (undefined method `each' for nil:NilClass) on line #113 of app/views/kata/help.html.erb:
110: </p>
111: 
112: <div class="hidden">
113:   <% @visible_files.each do |filename,file| -%>
114:     <div id="<%=filename-%>_div">
115:       <textarea id="<%=filename-%>" 
116:                 name="<%=filename-%>"><%= h file[:content] -%></textarea>

    app/views/kata/help.html.erb:113
    passenger (2.2.7) lib/phusion_passenger/rack/request_handler.rb:95:in `process_request'
    passenger (2.2.7) lib/phusion_passenger/abstract_request_handler.rb:207:in `main_loop'
    passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:374:in `start_request_handler'
    passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:332:in `handle_spawn_application'
    passenger (2.2.7) lib/phusion_passenger/utils.rb:184:in `safe_fork'
    passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:330:in `handle_spawn_application'
    passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
    passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
    passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'
    passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:163:in `start'
    passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:209:in `start'
    passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:262:in `spawn_rails_application'
    passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:126:in `lookup_or_add'
    passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:256:in `spawn_rails_application'
    passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:80:in `synchronize'
    passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:79:in `synchronize'
    passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:255:in `spawn_rails_application'
    passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:154:in `spawn_application'
    passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:287:in `handle_spawn_application'
    passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
    passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
    passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'

Rendering rescues/layout (internal_server_error)


Processing KataController#help (for 127.0.0.1 at 2010-01-12 14:44:43) [GET]
Rendering template within layouts/application
Rendering kata/help
Completed in 17ms (View: 16, DB: 0) | 200 OK [http://localhost/kata/help]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 14:44:57) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 177ms (View: 175, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing DojoController#help (for 127.0.0.1 at 2010-01-12 14:44:59) [GET]
Rendering template within layouts/application
Rendering dojo/help
Completed in 3ms (View: 3, DB: 0) | 200 OK [http://localhost/dojo/help]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 15:41:40) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 201ms (View: 186, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 15:41:59) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"      ", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\r\n#define UNSPLICE_INCLUDED\r\n\r\nvoid unsplice(char line[]);\r\n\r\n#endif\r\n\r\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \r\n\r\nPlease remember \r\n  o) we are not, repeat not, producing software to sell!\r\n  o) the sole aim of the game is to practice\r\n\r\nPracticing means\r\n  o) doing something just beyond your current ability\r\n  o) going slow, not rushing\r\n  o) analyzing your performance during the practice\r\n  o) analysing your performance after the practice\r\n  o) repeating the practice\r\n\r\nDuring the game please write notes in this file only.\r\n\r\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \r\nof the two characters \\ (backslash) and \\n (newline) when \r\nthey occur consecutively in an array of chars.\r\n\r\nSome examples:\r\n\r\nBefore  \"abc\\\\ndef\"\r\nAfter   \"abcdef\"\r\nThe unsplice operation has removed one occurence of the \r\nbackslash newline pair.\r\n\r\nBefore   \"abc\\d\\nef\"\r\nAfter    \"abc\\d\\nef\"\r\nThe unspliced version is unchanged because the backslash \r\nand newline characters are not consecutive.\r\n\r\nBefore   \"abc\\n\\def\"\r\nAfter    \"abc\\n\\def\"\r\nThe unspliced version is unchanged because the backslash \r\nand newline characters are in the wrong order.\r\n\r\nBefore  \"abc\\\\nde\\\\nfg\"\r\nAfter   \"abcdefg\"\r\nThe unsplice operation has removed two occurences of the \r\nbackslash newline pair.\r\n\r\nBefore   \"abc\\\\\\n\\ndef\"\r\nAfter    \"abc\\\\ndef\"\r\nThe unspliced operation has removed one occurence of the \r\nbackslash newline pair. Note that another occurence of the \r\nbackslash newline pair remains. The unsplice operation is \r\n'one-pass only'.\r\n\r\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\r\n#include \"tequila.h\"\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nvoid unsplice_tests(void)\r\n{\r\n    typedef const char * string;\t\t\r\n    TEST(\"that line with no splices is unchanged\")\r\n    {\r\n        const char * expected = \"abc\";\r\n        char actual[] = \"abc\";\r\n        unsplice(actual);\r\n        ARE_EQUAL(string, actual, expected);\r\n    }\r\n}\r\n\r\nconst tequila_test_function slammers[] =\r\n{\r\n    TEQUILA(unsplice_tests),\r\n};\r\n\r\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\r\n\r\nint main()\r\n{\r\n    tequila_test_suite suite;\r\n    tequila_test_count count;\r\n\r\n    tequila_init(&suite);\r\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\r\n    count = tequila_run(&suite);\r\n    tequila_report(&count);\r\n\t\r\n    return tequila_outcome(&count);\r\n}\r\n\r\n//------------------------------------------------------------\r\n\r\nbool tequila_equal_string(const char * lhs, const char * rhs)\r\n{\r\n\treturn (lhs == NULL && rhs == NULL) ||\r\n\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\r\n}\r\n\r\n#define STR(s) \"[\" #s \"]\"\r\n\r\n//TODO: make this the only function the user needs to supply.\r\nvoid tequila_print_string(FILE * out, const char * s)\r\n{\r\n\tif (s == NULL)\r\n\t\tfprintf(out, \"NULL\");\r\n\telse if (strlen(s) == 0)\r\n\t\tfprintf(out, \"\\\"\\\"\");\r\n\telse\r\n\t\tfor (size_t at = 0; at != strlen(s); at++)\r\n\t\t{\r\n\t\t\tchar c = s[at];\r\n\t\t\t// TODO: refactor to table driven\r\n\t\t\tswitch (c)\r\n\t\t\t{\r\n\t\t\t\tcase '\\\\': fprintf(out, STR('\\\\')); break;\r\n\t\t\t\tcase '\\a': fprintf(out, STR('\\a')); break;\r\n\t\t\t\tcase '\\b': fprintf(out, STR('\\b')); break;\r\n\t\t\t\tcase '\\f': fprintf(out, STR('\\f')); break;\r\n\t\t\t\tcase '\\n': fprintf(out, STR('\\n')); break;\r\n\t\t\t\tcase '\\r': fprintf(out, STR('\\r')); break;\r\n\t\t\t\tcase '\\t': fprintf(out, STR('\\t')); break;\r\n\t\t\t\tcase '\\v': fprintf(out, STR('\\v')); break;\r\n\t\t\t\t// TODO: check if isprint(c) if not print int value\r\n\t\t\t\tdefault  : fprintf(out, \"['%c' ]\", c); break;\r\n\t\t\t}\t\t\r\n\t\t}\r\n}\r\n\r\n// TODO: push this inside the framework\r\nvoid tequila_diff_print_string(\r\n\t\tconst char * s_type,\r\n\t\tconst char * expected, const char * actual,\r\n\t\tconst char * e_str, const char * a_str)\r\n{\r\n\tFILE * out = stderr;\r\n\r\n\ttequila_test_block * test_block = tequila_get_test_block();\r\n\r\n\tconst char * tab = \"    \";\r\n\tfprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \r\n\t\ttest_block->filename, test_block->line_number, \r\n\t\ttest_block->function->name, test_block->name);\r\n\r\n\tfprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\r\n\t\ttab, s_type, e_str, a_str);\r\n\r\n\tfprintf(out, \"%s%s\\n\", tab, e_str);\r\n\tfprintf(out, \"%s%s== \", tab, tab);\r\n\ttequila_print_string(out, expected);\r\n\tfprintf(out, \"\\n\");\r\n\r\n\tfprintf(out, \"%s%s\\n\", tab, a_str);\r\n\tfprintf(out, \"%s%s== \", tab, tab);\r\n\ttequila_print_string(out, actual);\r\n\tfprintf(out, \"\\n\");\r\n\tfprintf(out, \"\\n\");\r\n}\r\n       \r\n        \r\n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\r\n./run.tests.exe\r\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\r\n", "unsplice.c"=>"#include \"unsplice.h\"\r\n\r\nvoid unsplice(char line[])\r\n{\r\n}\r\n\r\n"}

NoMethodError (undefined method `call' for nil:NilClass):
  app/controllers/kata_controller.rb:66:in `run_tests'
  passenger (2.2.7) lib/phusion_passenger/rack/request_handler.rb:95:in `process_request'
  passenger (2.2.7) lib/phusion_passenger/abstract_request_handler.rb:207:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:374:in `start_request_handler'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:332:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/utils.rb:184:in `safe_fork'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:330:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:163:in `start'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:209:in `start'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:262:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:126:in `lookup_or_add'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:256:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:80:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:79:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:255:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:154:in `spawn_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:287:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'

Rendering rescues/layout (internal_server_error)


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 15:43:16) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 14ms (View: 13, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 15:43:19) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 200ms (View: 194, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 15:45:38) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1253ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 15:45:43) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])s\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])s\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1256ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 15:50:57) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 16ms (View: 14, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 15:51:00) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}

NoMethodError (undefined method `[]' for nil:NilClass):
  app/controllers/kata_controller.rb:34:in `start'
  passenger (2.2.7) lib/phusion_passenger/rack/request_handler.rb:95:in `process_request'
  passenger (2.2.7) lib/phusion_passenger/abstract_request_handler.rb:207:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:374:in `start_request_handler'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:332:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/utils.rb:184:in `safe_fork'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:330:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:163:in `start'
  passenger (2.2.7) lib/phusion_passenger/railz/application_spawner.rb:209:in `start'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:262:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:126:in `lookup_or_add'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:256:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:80:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/abstract_server_collection.rb:79:in `synchronize'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:255:in `spawn_rails_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:154:in `spawn_application'
  passenger (2.2.7) lib/phusion_passenger/spawn_manager.rb:287:in `handle_spawn_application'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `__send__'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:352:in `main_loop'
  passenger (2.2.7) lib/phusion_passenger/abstract_server.rb:196:in `start_synchronously'

Rendering rescues/layout (internal_server_error)


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 15:51:49) [GET]
Rendering template within layouts/application
Rendering dojo/index
Completed in 17ms (View: 15, DB: 0) | 200 OK [http://localhost/]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 15:51:54) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 205ms (View: 201, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 15:54:53) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"unsplice.c: In function 'unsplice':\\n\", \"unsplice.c:3: error: expected declaration specifiers before 's'\\n\", \"unsplice.c:5: error: expected '{' at end of input\\n\", \"make: *** [run.tests.exe] Error 1\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char line[])s\\n{\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])s\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\nunsplice.c: In function 'unsplice':\nunsplice.c:3: error: expected declaration specifiers before 's'\nunsplice.c:5: error: expected '{' at end of input\nmake: *** [run.tests.exe] Error 1\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])s\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1492ms (View: 175, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 15:55:04) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"unsplice.c: In function 'unsplice':\\n\", \"unsplice.c:3: error: expected declaration specifiers before 's'\\n\", \"unsplice.c:5: error: expected '{' at end of input\\n\", \"make: *** [run.tests.exe] Error 1\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char line[])s\\n{\\n}\\n\\n\"}}, :unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\"}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1285ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 15:55:07) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 8ms (View: 6, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 15:55:13) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Frogs", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Frogs"}
Rendering template within layouts/application
Rendering kata/start
Completed in 12ms (View: 11, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 15:55:17) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\", :visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\r\\n#define UNSPLICE_INCLUDED\\r\\n\\r\\nvoid unsplice(char line[]);\\r\\n\\r\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"\\nYour task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;\\t\\t\\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n\\t\\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n\\treturn (lhs == NULL && rhs == NULL) ||\\n\\t       (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n\\tif (s == NULL)\\n\\t\\tfprintf(out, \\\"NULL\\\");\\n\\telse if (strlen(s) == 0)\\n\\t\\tfprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n\\telse\\n\\t\\tfor (size_t at = 0; at != strlen(s); at++)\\n\\t\\t{\\n\\t\\t\\tchar c = s[at];\\n\\t\\t\\t// TODO: refactor to table driven\\n\\t\\t\\tswitch (c)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n\\t\\t\\t\\tcase '\\\\a': fprintf(out, STR('\\\\a')); break;\\n\\t\\t\\t\\tcase '\\\\b': fprintf(out, STR('\\\\b')); break;\\n\\t\\t\\t\\tcase '\\\\f': fprintf(out, STR('\\\\f')); break;\\n\\t\\t\\t\\tcase '\\\\n': fprintf(out, STR('\\\\n')); break;\\n\\t\\t\\t\\tcase '\\\\r': fprintf(out, STR('\\\\r')); break;\\n\\t\\t\\t\\tcase '\\\\t': fprintf(out, STR('\\\\t')); break;\\n\\t\\t\\t\\tcase '\\\\v': fprintf(out, STR('\\\\v')); break;\\n\\t\\t\\t\\t// TODO: check if isprint(c) if not print int value\\n\\t\\t\\t\\tdefault  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n\\t\\tconst char * s_type,\\n\\t\\tconst char * expected, const char * actual,\\n\\t\\tconst char * e_str, const char * a_str)\\n{\\n\\tFILE * out = stderr;\\n\\n\\ttequila_test_block * test_block = tequila_get_test_block();\\n\\n\\tconst char * tab = \\\"    \\\";\\n\\tfprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n\\t\\ttest_block->filename, test_block->line_number, \\n\\t\\ttest_block->function->name, test_block->name);\\n\\n\\tfprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n\\t\\ttab, s_type, e_str, a_str);\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, expected);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\n\\tfprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n\\tfprintf(out, \\\"%s%s== \\\", tab, tab);\\n\\ttequila_print_string(out, actual);\\n\\tfprintf(out, \\\"\\\\n\\\");\\n\\tfprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n./run.tests.exe\\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\r\\n\\r\\nvoid unsplice(char line[])\\r\\n{\\r\\n}\\n\\n\"}}}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Frogs", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char line[])\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1290ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Frogs&kata_id=99]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 15:55:25) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 7ms (View: 7, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 15:55:29) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"99", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 9ms (View: 8, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 15:55:39) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\", :visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"./run.tests.exe\\n\", \"TEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char * line)\\n{\\n}\\n\\n\"}}}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"xabc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"xabc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "run_tests_output"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1267ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 16:10:47) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\", :visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"./run.tests.exe\\n\", \"TEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char * line)\\n{\\n}\\n\\n\"}}}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nunsplice.tests.c:9: unsplice_tests() TEST(\"that line with no splices is unchanged\")\n    ARE_EQUAL(string, actual, expected);\n    actual\n        == ['x' ]['a' ]['b' ]['c' ]\n    expected\n        == ['a' ]['b' ]['c' ]\n\nTEQUILA FAILED: 0 passed, 1 failed, 0 unknown, ignored(0+0+0)\nmake: *** [run.tests] Error 1\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"xabc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1480ms (View: 175, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 16:10:59) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\", :visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"./run.tests.exe\\n\", \"TEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char * line)\\n{\\n}\\n\\n\"}}}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1279ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 16:14:43) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\", :visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"./run.tests.exe\\n\", \"TEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char * line)\\n{\\n}\\n\\n\"}}}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1469ms (View: 171, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 16:14:55) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\", :visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"./run.tests.exe\\n\", \"TEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char * line)\\n{\\n}\\n\\n\"}}}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n    for(;;);\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n    for(;;);\n}\n\n"}
Rendering kata/run_tests
Completed in 10215ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 16:15:53) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\", :visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"./run.tests.exe\\n\", \"TEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char * line)\\n{\\n}\\n\\n\"}}}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"run-tests stopped as it did not finish within 10 seconds", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n    for(;;);\n}\n\n"}
Rendering kata/run_tests
Completed in 10289ms (View: 10, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 16:16:10) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\", :visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"./run.tests.exe\\n\", \"TEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char * line)\\n{\\n}\\n\\n\"}}}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n}\n\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1256ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 16:22:27) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:unit_test_framework=>\"tequila\", :hidden_files=>{\"makefile\"=>{}, \"kata.sh\"=>{:permissions=>493}, \"tequila.h\"=>{}, \"tequila.c\"=>{}}, :max_run_tests_duration=>10, :language=>\"c\", :visible_files=>{\"unsplice.h\"=>{:content=>\"#ifndef UNSPLICE_INCLUDED\\n#define UNSPLICE_INCLUDED\\n\\nvoid unsplice(char line[]);\\n\\n#endif\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to write a function to remove all occurences \\nof the two characters \\\\ (backslash) and \\\\n (newline) when \\nthey occur consecutively in an array of chars.\\n\\nSome examples:\\n\\nBefore  \\\"abc\\\\\\\\ndef\\\"\\nAfter   \\\"abcdef\\\"\\nThe unsplice operation has removed one occurence of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\d\\\\nef\\\"\\nAfter    \\\"abc\\\\d\\\\nef\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are not consecutive.\\n\\nBefore   \\\"abc\\\\n\\\\def\\\"\\nAfter    \\\"abc\\\\n\\\\def\\\"\\nThe unspliced version is unchanged because the backslash \\nand newline characters are in the wrong order.\\n\\nBefore  \\\"abc\\\\\\\\nde\\\\\\\\nfg\\\"\\nAfter   \\\"abcdefg\\\"\\nThe unsplice operation has removed two occurences of the \\nbackslash newline pair.\\n\\nBefore   \\\"abc\\\\\\\\\\\\n\\\\ndef\\\"\\nAfter    \\\"abc\\\\\\\\ndef\\\"\\nThe unspliced operation has removed one occurence of the \\nbackslash newline pair. Note that another occurence of the \\nbackslash newline pair remains. The unsplice operation is \\n'one-pass only'.\\n\\n\"}, \"unsplice.tests.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n#include \\\"tequila.h\\\"\\n#include <stdio.h>\\n#include <string.h>\\n\\nvoid unsplice_tests(void)\\n{\\n    typedef const char * string;        \\n    TEST(\\\"that line with no splices is unchanged\\\")\\n    {\\n        const char * expected = \\\"abc\\\";\\n        char actual[] = \\\"abc\\\";\\n        unsplice(actual);\\n        ARE_EQUAL(string, actual, expected);\\n    }\\n}\\n\\nconst tequila_test_function slammers[] =\\n{\\n    TEQUILA(unsplice_tests),\\n};\\n\\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\\n\\nint main()\\n{\\n    tequila_test_suite suite;\\n    tequila_test_count count;\\n\\n    tequila_init(&suite);\\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\\n    count = tequila_run(&suite);\\n    tequila_report(&count);\\n    \\n    return tequila_outcome(&count);\\n}\\n\\n//------------------------------------------------------------\\n\\nbool tequila_equal_string(const char * lhs, const char * rhs)\\n{\\n    return (lhs == NULL && rhs == NULL) ||\\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\\n}\\n\\n#define STR(s) \\\"[\\\" #s \\\"]\\\"\\n\\n//TODO: make this the only function the user needs to supply.\\nvoid tequila_print_string(FILE * out, const char * s)\\n{\\n    if (s == NULL)\\n        fprintf(out, \\\"NULL\\\");\\n    else if (strlen(s) == 0)\\n        fprintf(out, \\\"\\\\\\\"\\\\\\\"\\\");\\n    else\\n        for (size_t at = 0; at != strlen(s); at++)\\n        {\\n            char c = s[at];\\n            // TODO: refactor to table driven\\n            switch (c)\\n            {\\n                case '\\\\\\\\': fprintf(out, STR('\\\\\\\\')); break;\\n                case '\\\\a': fprintf(out, STR('\\\\a')); break;\\n                case '\\\\b': fprintf(out, STR('\\\\b')); break;\\n                case '\\\\f': fprintf(out, STR('\\\\f')); break;\\n                case '\\\\n': fprintf(out, STR('\\\\n')); break;\\n                case '\\\\r': fprintf(out, STR('\\\\r')); break;\\n                case '\\\\t': fprintf(out, STR('\\\\t')); break;\\n                case '\\\\v': fprintf(out, STR('\\\\v')); break;\\n                // TODO: check if isprint(c) if not print int value\\n                default  : fprintf(out, \\\"['%c' ]\\\", c); break;\\n            }       \\n        }\\n}\\n\\n// TODO: push this inside the framework\\nvoid tequila_diff_print_string(\\n        const char * s_type,\\n        const char * expected, const char * actual,\\n        const char * e_str, const char * a_str)\\n{\\n    FILE * out = stderr;\\n\\n    tequila_test_block * test_block = tequila_get_test_block();\\n\\n    const char * tab = \\\"    \\\";\\n    fprintf(out, \\\"%s:%zd: %s() TEST(%s)\\\\n\\\", \\n        test_block->filename, test_block->line_number, \\n        test_block->function->name, test_block->name);\\n\\n    fprintf(out, \\\"%sARE_EQUAL(%s, %s, %s);\\\\n\\\",\\n        tab, s_type, e_str, a_str);\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, e_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, expected);\\n    fprintf(out, \\\"\\\\n\\\");\\n\\n    fprintf(out, \\\"%s%s\\\\n\\\", tab, a_str);\\n    fprintf(out, \\\"%s%s== \\\", tab, tab);\\n    tequila_print_string(out, actual);\\n    fprintf(out, \\\"\\\\n\\\");\\n    fprintf(out, \\\"\\\\n\\\");\\n}\\n       \\n        \\n\"}, \"run_tests_output\"=>{:content=>[\"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\\n\", \"./run.tests.exe\\n\", \"TEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\\n\"]}, \"unsplice.c\"=>{:content=>\"#include \\\"unsplice.h\\\"\\n\\nvoid unsplice(char * line)\\n{\\n}\\n\\n\"}}}", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"gcc -Wall -Werror -std=c99 *.c -o run.tests.exe\n./run.tests.exe\nTEQUILA PASSED: 1 passed, 0 failed, 0 unknown, ignored(0+0+0)\n", "unsplice.h"=>"#ifndef UNSPLICE_INCLUDED\n#define UNSPLICE_INCLUDED\n\nvoid unsplice(char line[]);\n\n#endif\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"99", "instructions"=>"Your task is to write a function to remove all occurences \nof the two characters \\ (backslash) and \\n (newline) when \nthey occur consecutively in an array of chars.\n\nSome examples:\n\nBefore  \"abc\\\\ndef\"\nAfter   \"abcdef\"\nThe unsplice operation has removed one occurence of the \nbackslash newline pair.\n\nBefore   \"abc\\d\\nef\"\nAfter    \"abc\\d\\nef\"\nThe unspliced version is unchanged because the backslash \nand newline characters are not consecutive.\n\nBefore   \"abc\\n\\def\"\nAfter    \"abc\\n\\def\"\nThe unspliced version is unchanged because the backslash \nand newline characters are in the wrong order.\n\nBefore  \"abc\\\\nde\\\\nfg\"\nAfter   \"abcdefg\"\nThe unsplice operation has removed two occurences of the \nbackslash newline pair.\n\nBefore   \"abc\\\\\\n\\ndef\"\nAfter    \"abc\\\\ndef\"\nThe unspliced operation has removed one occurence of the \nbackslash newline pair. Note that another occurence of the \nbackslash newline pair remains. The unsplice operation is \n'one-pass only'.\n\n", "unsplice.tests.c"=>"#include \"unsplice.h\"\n#include \"tequila.h\"\n#include <stdio.h>\n#include <string.h>\n\nvoid unsplice_tests(void)\n{\n    typedef const char * string;        \n    TEST(\"that line with no splices is unchanged\")\n    {\n        const char * expected = \"abc\";\n        char actual[] = \"abc\";\n        unsplice(actual);\n        ARE_EQUAL(string, actual, expected);\n    }\n}\n\nconst tequila_test_function slammers[] =\n{\n    TEQUILA(unsplice_tests),\n};\n\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\nint main()\n{\n    tequila_test_suite suite;\n    tequila_test_count count;\n\n    tequila_init(&suite);\n    tequila_add(&suite, ARRAY_SIZE(slammers), slammers);\n    count = tequila_run(&suite);\n    tequila_report(&count);\n    \n    return tequila_outcome(&count);\n}\n\n//------------------------------------------------------------\n\nbool tequila_equal_string(const char * lhs, const char * rhs)\n{\n    return (lhs == NULL && rhs == NULL) ||\n           (lhs != NULL && rhs != NULL && strcmp(lhs, rhs) == 0);\n}\n\n#define STR(s) \"[\" #s \"]\"\n\n//TODO: make this the only function the user needs to supply.\nvoid tequila_print_string(FILE * out, const char * s)\n{\n    if (s == NULL)\n        fprintf(out, \"NULL\");\n    else if (strlen(s) == 0)\n        fprintf(out, \"\\\"\\\"\");\n    else\n        for (size_t at = 0; at != strlen(s); at++)\n        {\n            char c = s[at];\n            // TODO: refactor to table driven\n            switch (c)\n            {\n                case '\\\\': fprintf(out, STR('\\\\')); break;\n                case '\\a': fprintf(out, STR('\\a')); break;\n                case '\\b': fprintf(out, STR('\\b')); break;\n                case '\\f': fprintf(out, STR('\\f')); break;\n                case '\\n': fprintf(out, STR('\\n')); break;\n                case '\\r': fprintf(out, STR('\\r')); break;\n                case '\\t': fprintf(out, STR('\\t')); break;\n                case '\\v': fprintf(out, STR('\\v')); break;\n                // TODO: check if isprint(c) if not print int value\n                default  : fprintf(out, \"['%c' ]\", c); break;\n            }       \n        }\n}\n\n// TODO: push this inside the framework\nvoid tequila_diff_print_string(\n        const char * s_type,\n        const char * expected, const char * actual,\n        const char * e_str, const char * a_str)\n{\n    FILE * out = stderr;\n\n    tequila_test_block * test_block = tequila_get_test_block();\n\n    const char * tab = \"    \";\n    fprintf(out, \"%s:%zd: %s() TEST(%s)\\n\", \n        test_block->filename, test_block->line_number, \n        test_block->function->name, test_block->name);\n\n    fprintf(out, \"%sARE_EQUAL(%s, %s, %s);\\n\",\n        tab, s_type, e_str, a_str);\n\n    fprintf(out, \"%s%s\\n\", tab, e_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, expected);\n    fprintf(out, \"\\n\");\n\n    fprintf(out, \"%s%s\\n\", tab, a_str);\n    fprintf(out, \"%s%s== \", tab, tab);\n    tequila_print_string(out, actual);\n    fprintf(out, \"\\n\");\n    fprintf(out, \"\\n\");\n}\n       \n        \n", "unsplice.c"=>"#include \"unsplice.h\"\n\nvoid unsplice(char * line)\n{\n}\n\n"}
Rendering kata/run_tests
Completed in 1327ms (View: 10, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=99]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 16:22:33) [GET]
  Parameters: {"id"=>"99"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 10ms (View: 9, DB: 0) | 200 OK [http://localhost/dojo/index/99]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 16:23:00) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Pandas", "start"=>"start", "kata_id"=>"8", "avatar_name"=>"Pandas"}
Rendering template within layouts/application
Rendering kata/start
Completed in 23ms (View: 13, DB: 0) | 200 OK [http://localhost/kata/start]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 16:23:17) [GET]
  Parameters: {"id"=>"8"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 5ms (View: 4, DB: 0) | 200 OK [http://localhost/dojo/index/8]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 16:23:42) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Raccoons", "start"=>"start", "kata_id"=>"10", "avatar_name"=>"Raccoons"}
Rendering template within layouts/application
Rendering kata/start
Completed in 24ms (View: 8, DB: 0) | 200 OK [http://localhost/kata/start]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 16:23:53) [GET]
  Parameters: {"id"=>"10"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 4ms (View: 4, DB: 0) | 200 OK [http://localhost/dojo/index/10]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 16:24:15) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Alligators", "start"=>"start", "kata_id"=>"11", "avatar_name"=>"Alligators"}
Rendering template within layouts/application
Rendering kata/start
Completed in 15ms (View: 8, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 16:24:48) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:hidden_files=>{\"kata.sh\"=>{:permissions=>493}}, :max_run_tests_duration=>10, :visible_files=>{\"roman.rb\"=>{:content=>\"class Roman\\n\\n  def initialize(value)\\n    @value = value\\n  end\\n\\n  def to_s\\n    \\\"i\\\"\\n  end\\n\\nend\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"test_roman.rb\"=>{:content=>\"require 'roman'\\nrequire 'test/unit'\\n\\nclass TestRoman < Test::Unit::TestCase\\n\\n  def test_simple\\n    assert_equal(\\\"i\\\", Roman.new(1).to_s)\\n  end\\n\\nend\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to convert numbers from arabic form to roman form.\\nSome examples:\\n\\nArabic: 1\\nRoman: \\\"i\\\"\\n\\nArabic: 2\\nRoman: \\\"ii\\\"\\n\\nArabic: 3\\nRoman: \\\"iii\\\"\\n\\nArabic: 4\\nRoman: \\\"iv\\\"\\n\\nArabic: 5\\nRoman: \\\"v\\\"\\n\\nArabic: 6\\nRoman: \\\"vi\\\"\\n\\nArabic: 7\\nRoman: \\\"vii\\\"\\n\\nArabic: 8\\nRoman: \\\"viii\\\"\\n\\nArabic: 9\\nRoman: \\\"ix\\\"\\n\\nArabic: 10\\nRoman: \\\"x\\\"\\n\\nArabic: 11\\nRoman: \\\"xi\\\"\\n\\nArabic: 15\\nRoman: \\\"xv\\\"\\n\\nArabic: 19\\nRoman: \\\"xix\\\"\\n\\nArabic: 40\\nRoman: \\\"xl\\\"   (x and lowercase L)\\n\\nArabic: 50\\nRoman: \\\"l\\\"    (lowercase L)\\n\\nArabic: 90\\nRoman: \\\"xc\\\"\\n\\nArabic: 100\\nRoman: \\\"c\\\"\\n\\nArabic: 400\\nRoman: \\\"cd\\\"\\n\\nArabic: 500\\nRoman: \\\"d\\\"\\n\\nArabic: 900\\nRoman: \\\"cm\\\"\\n\\nArabic: 1000\\nRoman: \\\"m\\\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}, \"run_tests_output\"=>{:content=>\"Loaded suite test_roman\\nStarted\\n.\\nFinished in 0.000255 seconds.\\n\\n1 tests, 1 assertions, 0 failures, 0 errors\\n\"}}, :unit_test_framework=>\"test_unit\", :language=>\"ruby\"}", "roman.rb"=>"class Roman\n\n  def initialize(value)\n    @value = value\n  end\n\n  def to_s\n    \"i\"\n  end\n\nend\n", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"ii\", Roman.new(1).to_s)\n  end\n\nend\n\n", "avatar"=>"Alligators", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "test_roman.rb"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"ii\", Roman.new(1).to_s)\n  end\n\nend\n\n", "kata_id"=>"11", "instructions"=>"Your task is to convert numbers from arabic form to roman form.\nSome examples:\n\nArabic: 1\nRoman: \"i\"\n\nArabic: 2\nRoman: \"ii\"\n\nArabic: 3\nRoman: \"iii\"\n\nArabic: 4\nRoman: \"iv\"\n\nArabic: 5\nRoman: \"v\"\n\nArabic: 6\nRoman: \"vi\"\n\nArabic: 7\nRoman: \"vii\"\n\nArabic: 8\nRoman: \"viii\"\n\nArabic: 9\nRoman: \"ix\"\n\nArabic: 10\nRoman: \"x\"\n\nArabic: 11\nRoman: \"xi\"\n\nArabic: 15\nRoman: \"xv\"\n\nArabic: 19\nRoman: \"xix\"\n\nArabic: 40\nRoman: \"xl\"   (x and lowercase L)\n\nArabic: 50\nRoman: \"l\"    (lowercase L)\n\nArabic: 90\nRoman: \"xc\"\n\nArabic: 100\nRoman: \"c\"\n\nArabic: 400\nRoman: \"cd\"\n\nArabic: 500\nRoman: \"d\"\n\nArabic: 900\nRoman: \"cm\"\n\nArabic: 1000\nRoman: \"m\"\n\n\n\n\n\n\n\n\n\n\n\n\n", "run_tests_output"=>"Loaded suite test_roman\nStarted\n.\nFinished in 0.000255 seconds.\n\n1 tests, 1 assertions, 0 failures, 0 errors\n"}
Rendering kata/run_tests
Completed in 1288ms (View: 105, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Alligators&kata_id=11]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 16:24:54) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:hidden_files=>{\"kata.sh\"=>{:permissions=>493}}, :max_run_tests_duration=>10, :visible_files=>{\"roman.rb\"=>{:content=>\"class Roman\\n\\n  def initialize(value)\\n    @value = value\\n  end\\n\\n  def to_s\\n    \\\"i\\\"\\n  end\\n\\nend\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"test_roman.rb\"=>{:content=>\"require 'roman'\\nrequire 'test/unit'\\n\\nclass TestRoman < Test::Unit::TestCase\\n\\n  def test_simple\\n    assert_equal(\\\"i\\\", Roman.new(1).to_s)\\n  end\\n\\nend\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to convert numbers from arabic form to roman form.\\nSome examples:\\n\\nArabic: 1\\nRoman: \\\"i\\\"\\n\\nArabic: 2\\nRoman: \\\"ii\\\"\\n\\nArabic: 3\\nRoman: \\\"iii\\\"\\n\\nArabic: 4\\nRoman: \\\"iv\\\"\\n\\nArabic: 5\\nRoman: \\\"v\\\"\\n\\nArabic: 6\\nRoman: \\\"vi\\\"\\n\\nArabic: 7\\nRoman: \\\"vii\\\"\\n\\nArabic: 8\\nRoman: \\\"viii\\\"\\n\\nArabic: 9\\nRoman: \\\"ix\\\"\\n\\nArabic: 10\\nRoman: \\\"x\\\"\\n\\nArabic: 11\\nRoman: \\\"xi\\\"\\n\\nArabic: 15\\nRoman: \\\"xv\\\"\\n\\nArabic: 19\\nRoman: \\\"xix\\\"\\n\\nArabic: 40\\nRoman: \\\"xl\\\"   (x and lowercase L)\\n\\nArabic: 50\\nRoman: \\\"l\\\"    (lowercase L)\\n\\nArabic: 90\\nRoman: \\\"xc\\\"\\n\\nArabic: 100\\nRoman: \\\"c\\\"\\n\\nArabic: 400\\nRoman: \\\"cd\\\"\\n\\nArabic: 500\\nRoman: \\\"d\\\"\\n\\nArabic: 900\\nRoman: \\\"cm\\\"\\n\\nArabic: 1000\\nRoman: \\\"m\\\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}, \"run_tests_output\"=>{:content=>\"Loaded suite test_roman\\nStarted\\n.\\nFinished in 0.000255 seconds.\\n\\n1 tests, 1 assertions, 0 failures, 0 errors\\n\"}}, :unit_test_framework=>\"test_unit\", :language=>\"ruby\"}", "roman.rb"=>"class Roman\n\n  def initialize(value)\n    @value = value\n  end\n\n  def to_s\n    \"i\"\n  end\n\nend\n", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"i\", Roman.new(1).to_s)\n  end\n\nend\n\n", "avatar"=>"Alligators", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "test_roman.rb"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"i\", Roman.new(1).to_s)\n  end\n\nend\n\n", "kata_id"=>"11", "instructions"=>"Your task is to convert numbers from arabic form to roman form.\nSome examples:\n\nArabic: 1\nRoman: \"i\"\n\nArabic: 2\nRoman: \"ii\"\n\nArabic: 3\nRoman: \"iii\"\n\nArabic: 4\nRoman: \"iv\"\n\nArabic: 5\nRoman: \"v\"\n\nArabic: 6\nRoman: \"vi\"\n\nArabic: 7\nRoman: \"vii\"\n\nArabic: 8\nRoman: \"viii\"\n\nArabic: 9\nRoman: \"ix\"\n\nArabic: 10\nRoman: \"x\"\n\nArabic: 11\nRoman: \"xi\"\n\nArabic: 15\nRoman: \"xv\"\n\nArabic: 19\nRoman: \"xix\"\n\nArabic: 40\nRoman: \"xl\"   (x and lowercase L)\n\nArabic: 50\nRoman: \"l\"    (lowercase L)\n\nArabic: 90\nRoman: \"xc\"\n\nArabic: 100\nRoman: \"c\"\n\nArabic: 400\nRoman: \"cd\"\n\nArabic: 500\nRoman: \"d\"\n\nArabic: 900\nRoman: \"cm\"\n\nArabic: 1000\nRoman: \"m\"\n\n\n\n\n\n\n\n\n\n\n\n\n"}
Rendering kata/run_tests
Completed in 1126ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Alligators&kata_id=11]


Processing KataController#see_all_increments (for 127.0.0.1 at 2010-01-12 16:24:57) [GET]
  Parameters: {"id"=>"11"}
Rendering template within layouts/application
Rendering kata/see_all_increments
Completed in 5ms (View: 4, DB: 0) | 200 OK [http://localhost/kata/see_all_increments/11]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 16:32:54) [GET]
  Parameters: {"id"=>"11"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 51ms (View: 49, DB: 0) | 200 OK [http://localhost/dojo/index/11]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 16:32:59) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Buffalos", "start"=>"start", "kata_id"=>"11", "avatar_name"=>"Buffalos"}
Rendering template within layouts/application
Rendering kata/start
Completed in 15ms (View: 12, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 16:33:09) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:max_run_tests_duration=>10, :unit_test_framework=>\"test_unit\", :hidden_files=>{\"kata.sh\"=>{:permissions=>493}}, :visible_files=>{\"roman.rb\"=>{:content=>\"class Roman\\n\\n  def initialize(value)\\n    @value = value\\n  end\\n\\n  def to_s\\n    \\\"i\\\"\\n  end\\n\\nend\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"test_roman.rb\"=>{:content=>\"require 'roman'\\nrequire 'test/unit'\\n\\nclass TestRoman < Test::Unit::TestCase\\n\\n  def test_simple\\n    assert_equal(\\\"i\\\", Roman.new(1).to_s)\\n  end\\n\\nend\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to convert numbers from arabic form to roman form.\\nSome examples:\\n\\nArabic: 1\\nRoman: \\\"i\\\"\\n\\nArabic: 2\\nRoman: \\\"ii\\\"\\n\\nArabic: 3\\nRoman: \\\"iii\\\"\\n\\nArabic: 4\\nRoman: \\\"iv\\\"\\n\\nArabic: 5\\nRoman: \\\"v\\\"\\n\\nArabic: 6\\nRoman: \\\"vi\\\"\\n\\nArabic: 7\\nRoman: \\\"vii\\\"\\n\\nArabic: 8\\nRoman: \\\"viii\\\"\\n\\nArabic: 9\\nRoman: \\\"ix\\\"\\n\\nArabic: 10\\nRoman: \\\"x\\\"\\n\\nArabic: 11\\nRoman: \\\"xi\\\"\\n\\nArabic: 15\\nRoman: \\\"xv\\\"\\n\\nArabic: 19\\nRoman: \\\"xix\\\"\\n\\nArabic: 40\\nRoman: \\\"xl\\\"   (x and lowercase L)\\n\\nArabic: 50\\nRoman: \\\"l\\\"    (lowercase L)\\n\\nArabic: 90\\nRoman: \\\"xc\\\"\\n\\nArabic: 100\\nRoman: \\\"c\\\"\\n\\nArabic: 400\\nRoman: \\\"cd\\\"\\n\\nArabic: 500\\nRoman: \\\"d\\\"\\n\\nArabic: 900\\nRoman: \\\"cm\\\"\\n\\nArabic: 1000\\nRoman: \\\"m\\\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}, \"run_tests_output\"=>{:content=>\"Loaded suite test_roman\\nStarted\\n.\\nFinished in 0.000255 seconds.\\n\\n1 tests, 1 assertions, 0 failures, 0 errors\\n\"}}, :language=>\"ruby\"}", "roman.rb"=>"class Roman\n\n  def initialize(value)\n    @value = value\n  end\n\n  def to_s\n    \"i\"\n  end\n\nend\n", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"Loaded suite test_roman\nStarted\n.\nFinished in 0.000255 seconds.\n\n1 tests, 1 assertions, 0 failures, 0 errors\n", "avatar"=>"Buffalos", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "test_roman.rb"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"i\", Roman.new(1).to_s)\n  end\n\nend\n\n", "kata_id"=>"11", "instructions"=>"Your task is to convert numbers from arabic form to roman form.\nSome examples:\n\nArabic: 1\nRoman: \"i\"\n\nArabic: 2\nRoman: \"ii\"\n\nArabic: 3\nRoman: \"iii\"\n\nArabic: 4\nRoman: \"iv\"\n\nArabic: 5\nRoman: \"v\"\n\nArabic: 6\nRoman: \"vi\"\n\nArabic: 7\nRoman: \"vii\"\n\nArabic: 8\nRoman: \"viii\"\n\nArabic: 9\nRoman: \"ix\"\n\nArabic: 10\nRoman: \"x\"\n\nArabic: 11\nRoman: \"xi\"\n\nArabic: 15\nRoman: \"xv\"\n\nArabic: 19\nRoman: \"xix\"\n\nArabic: 40\nRoman: \"xl\"   (x and lowercase L)\n\nArabic: 50\nRoman: \"l\"    (lowercase L)\n\nArabic: 90\nRoman: \"xc\"\n\nArabic: 100\nRoman: \"c\"\n\nArabic: 400\nRoman: \"cd\"\n\nArabic: 500\nRoman: \"d\"\n\nArabic: 900\nRoman: \"cm\"\n\nArabic: 1000\nRoman: \"m\"\n\n\n\n\n\n\n\n\n\n\n\n\n", "run_tests_output"=>"Loaded suite test_roman\nStarted\n.\nFinished in 0.000255 seconds.\n\n1 tests, 1 assertions, 0 failures, 0 errors\n"}
Rendering kata/run_tests
Completed in 1104ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Buffalos&kata_id=11]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 16:33:19) [GET]
  Parameters: {"id"=>"11"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 4ms (View: 4, DB: 0) | 200 OK [http://localhost/dojo/index/11]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 16:38:31) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"11", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 24ms (View: 21, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 16:38:44) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:max_run_tests_duration=>10, :unit_test_framework=>\"test_unit\", :hidden_files=>{\"kata.sh\"=>{:permissions=>493}}, :visible_files=>{\"roman.rb\"=>{:content=>\"class Roman\\n\\n  def initialize(value)\\n    @value = value\\n  end\\n\\n  def to_s\\n    \\\"i\\\"\\n  end\\n\\nend\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"test_roman.rb\"=>{:content=>\"require 'roman'\\nrequire 'test/unit'\\n\\nclass TestRoman < Test::Unit::TestCase\\n\\n  def test_simple\\n    assert_equal(\\\"i\\\", Roman.new(1).to_s)\\n  end\\n\\nend\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to convert numbers from arabic form to roman form.\\nSome examples:\\n\\nArabic: 1\\nRoman: \\\"i\\\"\\n\\nArabic: 2\\nRoman: \\\"ii\\\"\\n\\nArabic: 3\\nRoman: \\\"iii\\\"\\n\\nArabic: 4\\nRoman: \\\"iv\\\"\\n\\nArabic: 5\\nRoman: \\\"v\\\"\\n\\nArabic: 6\\nRoman: \\\"vi\\\"\\n\\nArabic: 7\\nRoman: \\\"vii\\\"\\n\\nArabic: 8\\nRoman: \\\"viii\\\"\\n\\nArabic: 9\\nRoman: \\\"ix\\\"\\n\\nArabic: 10\\nRoman: \\\"x\\\"\\n\\nArabic: 11\\nRoman: \\\"xi\\\"\\n\\nArabic: 15\\nRoman: \\\"xv\\\"\\n\\nArabic: 19\\nRoman: \\\"xix\\\"\\n\\nArabic: 40\\nRoman: \\\"xl\\\"   (x and lowercase L)\\n\\nArabic: 50\\nRoman: \\\"l\\\"    (lowercase L)\\n\\nArabic: 90\\nRoman: \\\"xc\\\"\\n\\nArabic: 100\\nRoman: \\\"c\\\"\\n\\nArabic: 400\\nRoman: \\\"cd\\\"\\n\\nArabic: 500\\nRoman: \\\"d\\\"\\n\\nArabic: 900\\nRoman: \\\"cm\\\"\\n\\nArabic: 1000\\nRoman: \\\"m\\\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}, \"run_tests_output\"=>{:content=>\"Loaded suite test_roman\\nStarted\\n.\\nFinished in 0.000255 seconds.\\n\\n1 tests, 1 assertions, 0 failures, 0 errors\\n\"}}, :language=>\"ruby\"}", "roman.rb"=>"class Roman\n\n  def initialize(value)\n    @value = value\n  end\n\n  def to_s\n    \"i\"\n  end\n\nend\n", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"ii\", Roman.new(1).to_s)\n  end\n\nend\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "test_roman.rb"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"ii\", Roman.new(1).to_s)\n  end\n\nend\n\n", "kata_id"=>"11", "instructions"=>"Your task is to convert numbers from arabic form to roman form.\nSome examples:\n\nArabic: 1\nRoman: \"i\"\n\nArabic: 2\nRoman: \"ii\"\n\nArabic: 3\nRoman: \"iii\"\n\nArabic: 4\nRoman: \"iv\"\n\nArabic: 5\nRoman: \"v\"\n\nArabic: 6\nRoman: \"vi\"\n\nArabic: 7\nRoman: \"vii\"\n\nArabic: 8\nRoman: \"viii\"\n\nArabic: 9\nRoman: \"ix\"\n\nArabic: 10\nRoman: \"x\"\n\nArabic: 11\nRoman: \"xi\"\n\nArabic: 15\nRoman: \"xv\"\n\nArabic: 19\nRoman: \"xix\"\n\nArabic: 40\nRoman: \"xl\"   (x and lowercase L)\n\nArabic: 50\nRoman: \"l\"    (lowercase L)\n\nArabic: 90\nRoman: \"xc\"\n\nArabic: 100\nRoman: \"c\"\n\nArabic: 400\nRoman: \"cd\"\n\nArabic: 500\nRoman: \"d\"\n\nArabic: 900\nRoman: \"cm\"\n\nArabic: 1000\nRoman: \"m\"\n\n\n\n\n\n\n\n\n\n\n\n\n", "run_tests_output"=>"Loaded suite test_roman\nStarted\n.\nFinished in 0.000255 seconds.\n\n1 tests, 1 assertions, 0 failures, 0 errors\n"}
Rendering kata/run_tests
Completed in 1134ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=11]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 16:38:55) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:max_run_tests_duration=>10, :unit_test_framework=>\"test_unit\", :hidden_files=>{\"kata.sh\"=>{:permissions=>493}}, :visible_files=>{\"roman.rb\"=>{:content=>\"class Roman\\n\\n  def initialize(value)\\n    @value = value\\n  end\\n\\n  def to_s\\n    \\\"i\\\"\\n  end\\n\\nend\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"test_roman.rb\"=>{:content=>\"require 'roman'\\nrequire 'test/unit'\\n\\nclass TestRoman < Test::Unit::TestCase\\n\\n  def test_simple\\n    assert_equal(\\\"i\\\", Roman.new(1).to_s)\\n  end\\n\\nend\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to convert numbers from arabic form to roman form.\\nSome examples:\\n\\nArabic: 1\\nRoman: \\\"i\\\"\\n\\nArabic: 2\\nRoman: \\\"ii\\\"\\n\\nArabic: 3\\nRoman: \\\"iii\\\"\\n\\nArabic: 4\\nRoman: \\\"iv\\\"\\n\\nArabic: 5\\nRoman: \\\"v\\\"\\n\\nArabic: 6\\nRoman: \\\"vi\\\"\\n\\nArabic: 7\\nRoman: \\\"vii\\\"\\n\\nArabic: 8\\nRoman: \\\"viii\\\"\\n\\nArabic: 9\\nRoman: \\\"ix\\\"\\n\\nArabic: 10\\nRoman: \\\"x\\\"\\n\\nArabic: 11\\nRoman: \\\"xi\\\"\\n\\nArabic: 15\\nRoman: \\\"xv\\\"\\n\\nArabic: 19\\nRoman: \\\"xix\\\"\\n\\nArabic: 40\\nRoman: \\\"xl\\\"   (x and lowercase L)\\n\\nArabic: 50\\nRoman: \\\"l\\\"    (lowercase L)\\n\\nArabic: 90\\nRoman: \\\"xc\\\"\\n\\nArabic: 100\\nRoman: \\\"c\\\"\\n\\nArabic: 400\\nRoman: \\\"cd\\\"\\n\\nArabic: 500\\nRoman: \\\"d\\\"\\n\\nArabic: 900\\nRoman: \\\"cm\\\"\\n\\nArabic: 1000\\nRoman: \\\"m\\\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}, \"run_tests_output\"=>{:content=>\"Loaded suite test_roman\\nStarted\\n.\\nFinished in 0.000255 seconds.\\n\\n1 tests, 1 assertions, 0 failures, 0 errors\\n\"}}, :language=>\"ruby\"}", "roman.rb"=>"class Roman\n\n  def initialize(value)\n    @value = value\n  end\n\n  def to_s\n    \"i\"\n  end\n\nend\n", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"i\", Roman.new(1).to_s)\n  end\n\nend\n\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "test_roman.rb"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"i\", Roman.new(1).to_s)\n  end\n\nend\n\n", "kata_id"=>"11", "instructions"=>"Your task is to convert numbers from arabic form to roman form.\nSome examples:\n\nArabic: 1\nRoman: \"i\"\n\nArabic: 2\nRoman: \"ii\"\n\nArabic: 3\nRoman: \"iii\"\n\nArabic: 4\nRoman: \"iv\"\n\nArabic: 5\nRoman: \"v\"\n\nArabic: 6\nRoman: \"vi\"\n\nArabic: 7\nRoman: \"vii\"\n\nArabic: 8\nRoman: \"viii\"\n\nArabic: 9\nRoman: \"ix\"\n\nArabic: 10\nRoman: \"x\"\n\nArabic: 11\nRoman: \"xi\"\n\nArabic: 15\nRoman: \"xv\"\n\nArabic: 19\nRoman: \"xix\"\n\nArabic: 40\nRoman: \"xl\"   (x and lowercase L)\n\nArabic: 50\nRoman: \"l\"    (lowercase L)\n\nArabic: 90\nRoman: \"xc\"\n\nArabic: 100\nRoman: \"c\"\n\nArabic: 400\nRoman: \"cd\"\n\nArabic: 500\nRoman: \"d\"\n\nArabic: 900\nRoman: \"cm\"\n\nArabic: 1000\nRoman: \"m\"\n\n\n\n\n\n\n\n\n\n\n\n\n"}
Rendering kata/run_tests
Completed in 1054ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=11]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 16:38:58) [GET]
  Parameters: {"increment"=>"1", "id"=>"11", "avatar"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 6ms (View: 5, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/11?avatar=Wolves&increment=1]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 16:41:46) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:max_run_tests_duration=>10, :unit_test_framework=>\"test_unit\", :hidden_files=>{\"kata.sh\"=>{:permissions=>493}}, :visible_files=>{\"roman.rb\"=>{:content=>\"class Roman\\n\\n  def initialize(value)\\n    @value = value\\n  end\\n\\n  def to_s\\n    \\\"i\\\"\\n  end\\n\\nend\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"test_roman.rb\"=>{:content=>\"require 'roman'\\nrequire 'test/unit'\\n\\nclass TestRoman < Test::Unit::TestCase\\n\\n  def test_simple\\n    assert_equal(\\\"i\\\", Roman.new(1).to_s)\\n  end\\n\\nend\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to convert numbers from arabic form to roman form.\\nSome examples:\\n\\nArabic: 1\\nRoman: \\\"i\\\"\\n\\nArabic: 2\\nRoman: \\\"ii\\\"\\n\\nArabic: 3\\nRoman: \\\"iii\\\"\\n\\nArabic: 4\\nRoman: \\\"iv\\\"\\n\\nArabic: 5\\nRoman: \\\"v\\\"\\n\\nArabic: 6\\nRoman: \\\"vi\\\"\\n\\nArabic: 7\\nRoman: \\\"vii\\\"\\n\\nArabic: 8\\nRoman: \\\"viii\\\"\\n\\nArabic: 9\\nRoman: \\\"ix\\\"\\n\\nArabic: 10\\nRoman: \\\"x\\\"\\n\\nArabic: 11\\nRoman: \\\"xi\\\"\\n\\nArabic: 15\\nRoman: \\\"xv\\\"\\n\\nArabic: 19\\nRoman: \\\"xix\\\"\\n\\nArabic: 40\\nRoman: \\\"xl\\\"   (x and lowercase L)\\n\\nArabic: 50\\nRoman: \\\"l\\\"    (lowercase L)\\n\\nArabic: 90\\nRoman: \\\"xc\\\"\\n\\nArabic: 100\\nRoman: \\\"c\\\"\\n\\nArabic: 400\\nRoman: \\\"cd\\\"\\n\\nArabic: 500\\nRoman: \\\"d\\\"\\n\\nArabic: 900\\nRoman: \\\"cm\\\"\\n\\nArabic: 1000\\nRoman: \\\"m\\\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}, \"run_tests_output\"=>{:content=>\"Loaded suite test_roman\\nStarted\\n.\\nFinished in 0.000255 seconds.\\n\\n1 tests, 1 assertions, 0 failures, 0 errors\\n\"}}, :language=>\"ruby\"}", "roman.rb"=>"class Roman\n\n  def initialize(value)\n    @value = value\n  end\n\n  def to_s\n    \"i\"\n  end\n\nend\n", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"Loaded suite test_roman\nStarted\n.\nFinished in 0.00032 seconds.\n\n1 tests, 1 assertions, 0 failures, 0 errors\n", "avatar"=>"Wolves", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "test_roman.rb"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"i\", Roman.new(1).to_s)\n  end\n\nend\n\n", "kata_id"=>"11", "instructions"=>"Your task is to convert numbers from arabic form to roman form.\nSome examples:\n\nArabic: 1\nRoman: \"i\"\n\nArabic: 2\nRoman: \"ii\"\n\nArabic: 3\nRoman: \"iii\"\n\nArabic: 4\nRoman: \"iv\"\n\nArabic: 5\nRoman: \"v\"\n\nArabic: 6\nRoman: \"vi\"\n\nArabic: 7\nRoman: \"vii\"\n\nArabic: 8\nRoman: \"viii\"\n\nArabic: 9\nRoman: \"ix\"\n\nArabic: 10\nRoman: \"x\"\n\nArabic: 11\nRoman: \"xi\"\n\nArabic: 15\nRoman: \"xv\"\n\nArabic: 19\nRoman: \"xix\"\n\nArabic: 40\nRoman: \"xl\"   (x and lowercase L)\n\nArabic: 50\nRoman: \"l\"    (lowercase L)\n\nArabic: 90\nRoman: \"xc\"\n\nArabic: 100\nRoman: \"c\"\n\nArabic: 400\nRoman: \"cd\"\n\nArabic: 500\nRoman: \"d\"\n\nArabic: 900\nRoman: \"cm\"\n\nArabic: 1000\nRoman: \"m\"\n\n\n\n\n\n\n\n\n\n\n\n\n"}
Rendering kata/run_tests
Completed in 1116ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Wolves&kata_id=11]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 16:41:50) [GET]
  Parameters: {"id"=>"11"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 7ms (View: 5, DB: 0) | 200 OK [http://localhost/dojo/index/11]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 16:41:54) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Zebras", "start"=>"start", "kata_id"=>"11", "avatar_name"=>"Zebras"}
Rendering template within layouts/application
Rendering kata/start
Completed in 8ms (View: 7, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 16:42:02) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:max_run_tests_duration=>10, :unit_test_framework=>\"test_unit\", :hidden_files=>{\"kata.sh\"=>{:permissions=>493}}, :visible_files=>{\"roman.rb\"=>{:content=>\"class Roman\\n\\n  def initialize(value)\\n    @value = value\\n  end\\n\\n  def to_s\\n    \\\"i\\\"\\n  end\\n\\nend\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"test_roman.rb\"=>{:content=>\"require 'roman'\\nrequire 'test/unit'\\n\\nclass TestRoman < Test::Unit::TestCase\\n\\n  def test_simple\\n    assert_equal(\\\"i\\\", Roman.new(1).to_s)\\n  end\\n\\nend\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to convert numbers from arabic form to roman form.\\nSome examples:\\n\\nArabic: 1\\nRoman: \\\"i\\\"\\n\\nArabic: 2\\nRoman: \\\"ii\\\"\\n\\nArabic: 3\\nRoman: \\\"iii\\\"\\n\\nArabic: 4\\nRoman: \\\"iv\\\"\\n\\nArabic: 5\\nRoman: \\\"v\\\"\\n\\nArabic: 6\\nRoman: \\\"vi\\\"\\n\\nArabic: 7\\nRoman: \\\"vii\\\"\\n\\nArabic: 8\\nRoman: \\\"viii\\\"\\n\\nArabic: 9\\nRoman: \\\"ix\\\"\\n\\nArabic: 10\\nRoman: \\\"x\\\"\\n\\nArabic: 11\\nRoman: \\\"xi\\\"\\n\\nArabic: 15\\nRoman: \\\"xv\\\"\\n\\nArabic: 19\\nRoman: \\\"xix\\\"\\n\\nArabic: 40\\nRoman: \\\"xl\\\"   (x and lowercase L)\\n\\nArabic: 50\\nRoman: \\\"l\\\"    (lowercase L)\\n\\nArabic: 90\\nRoman: \\\"xc\\\"\\n\\nArabic: 100\\nRoman: \\\"c\\\"\\n\\nArabic: 400\\nRoman: \\\"cd\\\"\\n\\nArabic: 500\\nRoman: \\\"d\\\"\\n\\nArabic: 900\\nRoman: \\\"cm\\\"\\n\\nArabic: 1000\\nRoman: \\\"m\\\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}, \"run_tests_output\"=>{:content=>\"Loaded suite test_roman\\nStarted\\n.\\nFinished in 0.000255 seconds.\\n\\n1 tests, 1 assertions, 0 failures, 0 errors\\n\"}}, :language=>\"ruby\"}", "roman.rb"=>"class Roman\n\n  def initialize(value)\n    @value = value\n  end\n\n  def to_s\n    \"i\"\n  end\n\nend\n", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"Loaded suite test_roman\nStarted\n.\nFinished in 0.000255 seconds.\n\n1 tests, 1 assertions, 0 failures, 0 errors\n", "avatar"=>"Zebras", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "test_roman.rb"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"i\", Roman.new(1).to_s)\n  end\n\nend\n\n", "kata_id"=>"11", "instructions"=>"Your task is to convert numbers from arabic form to roman form.\nSome examples:\n\nArabic: 1\nRoman: \"i\"\n\nArabic: 2\nRoman: \"ii\"\n\nArabic: 3\nRoman: \"iii\"\n\nArabic: 4\nRoman: \"iv\"\n\nArabic: 5\nRoman: \"v\"\n\nArabic: 6\nRoman: \"vi\"\n\nArabic: 7\nRoman: \"vii\"\n\nArabic: 8\nRoman: \"viii\"\n\nArabic: 9\nRoman: \"ix\"\n\nArabic: 10\nRoman: \"x\"\n\nArabic: 11\nRoman: \"xi\"\n\nArabic: 15\nRoman: \"xv\"\n\nArabic: 19\nRoman: \"xix\"\n\nArabic: 40\nRoman: \"xl\"   (x and lowercase L)\n\nArabic: 50\nRoman: \"l\"    (lowercase L)\n\nArabic: 90\nRoman: \"xc\"\n\nArabic: 100\nRoman: \"c\"\n\nArabic: 400\nRoman: \"cd\"\n\nArabic: 500\nRoman: \"d\"\n\nArabic: 900\nRoman: \"cm\"\n\nArabic: 1000\nRoman: \"m\"\n\n\n\n\n\n\n\n\n\n\n\n\n", "run_tests_output"=>"Loaded suite test_roman\nStarted\n.\nFinished in 0.000255 seconds.\n\n1 tests, 1 assertions, 0 failures, 0 errors\n"}
Rendering kata/run_tests
Completed in 1086ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Zebras&kata_id=11]


Processing KataController#see_all_increments (for 127.0.0.1 at 2010-01-12 16:42:06) [GET]
  Parameters: {"id"=>"11"}
Rendering template within layouts/application
Rendering kata/see_all_increments
Completed in 5ms (View: 4, DB: 0) | 200 OK [http://localhost/kata/see_all_increments/11]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 16:42:15) [GET]
  Parameters: {"increment"=>"3", "id"=>"11", "avatar"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 5ms (View: 4, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/11?avatar=Wolves&increment=3]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 16:42:23) [GET]
  Parameters: {"id"=>"11"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 4ms (View: 4, DB: 0) | 200 OK [http://localhost/dojo/index/11]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 16:42:30) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Wolves", "start"=>"start", "kata_id"=>"11", "avatar_name"=>"Wolves"}
Rendering template within layouts/application
Rendering kata/start
Completed in 11ms (View: 9, DB: 0) | 200 OK [http://localhost/kata/start]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 16:42:47) [GET]
  Parameters: {"id"=>"11"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 5ms (View: 5, DB: 0) | 200 OK [http://localhost/dojo/index/11]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 16:45:20) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Koalas", "start"=>"start", "kata_id"=>"11", "avatar_name"=>"Koalas"}
Rendering template within layouts/application
Rendering kata/start
Completed in 8ms (View: 7, DB: 0) | 200 OK [http://localhost/kata/start]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 16:55:33) [GET]
  Parameters: {"id"=>"11"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 15ms (View: 13, DB: 0) | 200 OK [http://localhost/dojo/index/11]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 16:55:37) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Koalas", "start"=>"start", "kata_id"=>"11", "avatar_name"=>"Koalas"}
Rendering template within layouts/application
Rendering kata/start
Completed in 295ms (View: 284, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 16:55:42) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"roman.rb\"=>{:content=>\"class Roman\\n\\n  def initialize(value)\\n    @value = value\\n  end\\n\\n  def to_s\\n    \\\"i\\\"\\n  end\\n\\nend\\n\"}, \"test_roman.rb\"=>{:content=>\"require 'roman'\\nrequire 'test/unit'\\n\\nclass TestRoman < Test::Unit::TestCase\\n\\n  def test_simple\\n    assert_equal(\\\"i\\\", Roman.new(1).to_s)\\n  end\\n\\nend\\n\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to convert numbers from arabic form to roman form.\\nSome examples:\\n\\nArabic: 1\\nRoman: \\\"i\\\"\\n\\nArabic: 2\\nRoman: \\\"ii\\\"\\n\\nArabic: 3\\nRoman: \\\"iii\\\"\\n\\nArabic: 4\\nRoman: \\\"iv\\\"\\n\\nArabic: 5\\nRoman: \\\"v\\\"\\n\\nArabic: 6\\nRoman: \\\"vi\\\"\\n\\nArabic: 7\\nRoman: \\\"vii\\\"\\n\\nArabic: 8\\nRoman: \\\"viii\\\"\\n\\nArabic: 9\\nRoman: \\\"ix\\\"\\n\\nArabic: 10\\nRoman: \\\"x\\\"\\n\\nArabic: 11\\nRoman: \\\"xi\\\"\\n\\nArabic: 15\\nRoman: \\\"xv\\\"\\n\\nArabic: 19\\nRoman: \\\"xix\\\"\\n\\nArabic: 40\\nRoman: \\\"xl\\\"   (x and lowercase L)\\n\\nArabic: 50\\nRoman: \\\"l\\\"    (lowercase L)\\n\\nArabic: 90\\nRoman: \\\"xc\\\"\\n\\nArabic: 100\\nRoman: \\\"c\\\"\\n\\nArabic: 400\\nRoman: \\\"cd\\\"\\n\\nArabic: 500\\nRoman: \\\"d\\\"\\n\\nArabic: 900\\nRoman: \\\"cm\\\"\\n\\nArabic: 1000\\nRoman: \\\"m\\\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}, \"run_tests_output\"=>{:content=>\"Loaded suite test_roman\\nStarted\\n.\\nFinished in 0.000255 seconds.\\n\\n1 tests, 1 assertions, 0 failures, 0 errors\\n\"}}, :language=>\"ruby\", :max_run_tests_duration=>10, :unit_test_framework=>\"test_unit\", :hidden_files=>{\"kata.sh\"=>{:permissions=>493}}}", "roman.rb"=>"class Roman\n\n  def initialize(value)\n    @value = value\n  end\n\n  def to_s\n    \"i\"\n  end\n\nend\n", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"Your task is to convert numbers from arabic form to roman form.\nSome examples:\n\nArabic: 1\nRoman: \"i\"\n\nArabic: 2\nRoman: \"ii\"\n\nArabic: 3\nRoman: \"iii\"\n\nArabic: 4\nRoman: \"iv\"\n\nArabic: 5\nRoman: \"v\"\n\nArabic: 6\nRoman: \"vi\"\n\nArabic: 7\nRoman: \"vii\"\n\nArabic: 8\nRoman: \"viii\"\n\nArabic: 9\nRoman: \"ix\"\n\nArabic: 10\nRoman: \"x\"\n\nArabic: 11\nRoman: \"xi\"\n\nArabic: 15\nRoman: \"xv\"\n\nArabic: 19\nRoman: \"xix\"\n\nArabic: 40\nRoman: \"xl\"   (x and lowercase L)\n\nArabic: 50\nRoman: \"l\"    (lowercase L)\n\nArabic: 90\nRoman: \"xc\"\n\nArabic: 100\nRoman: \"c\"\n\nArabic: 400\nRoman: \"cd\"\n\nArabic: 500\nRoman: \"d\"\n\nArabic: 900\nRoman: \"cm\"\n\nArabic: 1000\nRoman: \"m\"\n\n\n\n\n\n\n\n\n\n\n\n\n", "avatar"=>"Koalas", "test_roman.rb"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"i\", Roman.new(1).to_s)\n  end\n\nend\n\n", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "kata_id"=>"11", "instructions"=>"Your task is to convert numbers from arabic form to roman form.\nSome examples:\n\nArabic: 1\nRoman: \"i\"\n\nArabic: 2\nRoman: \"ii\"\n\nArabic: 3\nRoman: \"iii\"\n\nArabic: 4\nRoman: \"iv\"\n\nArabic: 5\nRoman: \"v\"\n\nArabic: 6\nRoman: \"vi\"\n\nArabic: 7\nRoman: \"vii\"\n\nArabic: 8\nRoman: \"viii\"\n\nArabic: 9\nRoman: \"ix\"\n\nArabic: 10\nRoman: \"x\"\n\nArabic: 11\nRoman: \"xi\"\n\nArabic: 15\nRoman: \"xv\"\n\nArabic: 19\nRoman: \"xix\"\n\nArabic: 40\nRoman: \"xl\"   (x and lowercase L)\n\nArabic: 50\nRoman: \"l\"    (lowercase L)\n\nArabic: 90\nRoman: \"xc\"\n\nArabic: 100\nRoman: \"c\"\n\nArabic: 400\nRoman: \"cd\"\n\nArabic: 500\nRoman: \"d\"\n\nArabic: 900\nRoman: \"cm\"\n\nArabic: 1000\nRoman: \"m\"\n\n\n\n\n\n\n\n\n\n\n\n\n", "run_tests_output"=>"Loaded suite test_roman\nStarted\n.\nFinished in 0.000255 seconds.\n\n1 tests, 1 assertions, 0 failures, 0 errors\n"}
Rendering kata/run_tests
Completed in 1120ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Koalas&kata_id=11]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 17:00:47) [GET]
  Parameters: {"id"=>"11"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 15ms (View: 14, DB: 0) | 200 OK [http://localhost/dojo/index/11]


Processing KataController#start (for 127.0.0.1 at 2010-01-12 17:00:50) [POST]
  Parameters: {"authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "avatar"=>"Koalas", "start"=>"start", "kata_id"=>"11", "avatar_name"=>"Koalas"}
Rendering template within layouts/application
Rendering kata/start
Completed in 283ms (View: 280, DB: 0) | 200 OK [http://localhost/kata/start]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 17:00:59) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"roman.rb\"=>{:content=>\"class Roman\\n\\n  def initialize(value)\\n    @value = value\\n  end\\n\\n  def to_s\\n    \\\"i\\\"\\n  end\\n\\nend\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"test_roman.rb\"=>{:content=>\"require 'roman'\\nrequire 'test/unit'\\n\\nclass TestRoman < Test::Unit::TestCase\\n\\n  def test_simple\\n    assert_equal(\\\"i\\\", Roman.new(1).to_s)\\n  end\\n\\nend\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to convert numbers from arabic form to roman form.\\nSome examples:\\n\\nArabic: 1\\nRoman: \\\"i\\\"\\n\\nArabic: 2\\nRoman: \\\"ii\\\"\\n\\nArabic: 3\\nRoman: \\\"iii\\\"\\n\\nArabic: 4\\nRoman: \\\"iv\\\"\\n\\nArabic: 5\\nRoman: \\\"v\\\"\\n\\nArabic: 6\\nRoman: \\\"vi\\\"\\n\\nArabic: 7\\nRoman: \\\"vii\\\"\\n\\nArabic: 8\\nRoman: \\\"viii\\\"\\n\\nArabic: 9\\nRoman: \\\"ix\\\"\\n\\nArabic: 10\\nRoman: \\\"x\\\"\\n\\nArabic: 11\\nRoman: \\\"xi\\\"\\n\\nArabic: 15\\nRoman: \\\"xv\\\"\\n\\nArabic: 19\\nRoman: \\\"xix\\\"\\n\\nArabic: 40\\nRoman: \\\"xl\\\"   (x and lowercase L)\\n\\nArabic: 50\\nRoman: \\\"l\\\"    (lowercase L)\\n\\nArabic: 90\\nRoman: \\\"xc\\\"\\n\\nArabic: 100\\nRoman: \\\"c\\\"\\n\\nArabic: 400\\nRoman: \\\"cd\\\"\\n\\nArabic: 500\\nRoman: \\\"d\\\"\\n\\nArabic: 900\\nRoman: \\\"cm\\\"\\n\\nArabic: 1000\\nRoman: \\\"m\\\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}, \"run_tests_output\"=>{:content=>\"Loaded suite test_roman\\nStarted\\n.\\nFinished in 0.000255 seconds.\\n\\n1 tests, 1 assertions, 0 failures, 0 errors\\n\"}}, :language=>\"ruby\", :max_run_tests_duration=>10, :unit_test_framework=>\"test_unit\", :hidden_files=>{\"kata.sh\"=>{:permissions=>493}}}", "roman.rb"=>"class Roman\n\n  def initialize(value)\n    @value = value\n  end\n\n  def to_s\n    \"i\"\n  end\n\nend\n", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"Loaded suite test_roman\nStarted\n.\nFinished in 0.000255 seconds.\n\n1 tests, 1 assertions, 0 failures, 0 errors\n", "avatar"=>"Koalas", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "test_roman.rb"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"i\", Roman.new(1).to_s)\n  end\n\nend\n\n", "kata_id"=>"11", "instructions"=>"Your task is to convert numbers from arabic form to roman form.\nSome examples:\n\nArabic: 1\nRoman: \"i\"\n\nArabic: 2\nRoman: \"ii\"\n\nArabic: 3\nRoman: \"iii\"\n\nArabic: 4\nRoman: \"iv\"\n\nArabic: 5\nRoman: \"v\"\n\nArabic: 6\nRoman: \"vi\"\n\nArabic: 7\nRoman: \"vii\"\n\nArabic: 8\nRoman: \"viii\"\n\nArabic: 9\nRoman: \"ix\"\n\nArabic: 10\nRoman: \"x\"\n\nArabic: 11\nRoman: \"xi\"\n\nArabic: 15\nRoman: \"xv\"\n\nArabic: 19\nRoman: \"xix\"\n\nArabic: 40\nRoman: \"xl\"   (x and lowercase L)\n\nArabic: 50\nRoman: \"l\"    (lowercase L)\n\nArabic: 90\nRoman: \"xc\"\n\nArabic: 100\nRoman: \"c\"\n\nArabic: 400\nRoman: \"cd\"\n\nArabic: 500\nRoman: \"d\"\n\nArabic: 900\nRoman: \"cm\"\n\nArabic: 1000\nRoman: \"m\"\n\n\n\n\n\n\n\n\n\n\n\n\n", "run_tests_output"=>"Loaded suite test_roman\nStarted\n.\nFinished in 0.000255 seconds.\n\n1 tests, 1 assertions, 0 failures, 0 errors\n"}
Rendering kata/run_tests
Completed in 1142ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Koalas&kata_id=11]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 17:01:02) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"roman.rb\"=>{:content=>\"class Roman\\n\\n  def initialize(value)\\n    @value = value\\n  end\\n\\n  def to_s\\n    \\\"i\\\"\\n  end\\n\\nend\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"test_roman.rb\"=>{:content=>\"require 'roman'\\nrequire 'test/unit'\\n\\nclass TestRoman < Test::Unit::TestCase\\n\\n  def test_simple\\n    assert_equal(\\\"i\\\", Roman.new(1).to_s)\\n  end\\n\\nend\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to convert numbers from arabic form to roman form.\\nSome examples:\\n\\nArabic: 1\\nRoman: \\\"i\\\"\\n\\nArabic: 2\\nRoman: \\\"ii\\\"\\n\\nArabic: 3\\nRoman: \\\"iii\\\"\\n\\nArabic: 4\\nRoman: \\\"iv\\\"\\n\\nArabic: 5\\nRoman: \\\"v\\\"\\n\\nArabic: 6\\nRoman: \\\"vi\\\"\\n\\nArabic: 7\\nRoman: \\\"vii\\\"\\n\\nArabic: 8\\nRoman: \\\"viii\\\"\\n\\nArabic: 9\\nRoman: \\\"ix\\\"\\n\\nArabic: 10\\nRoman: \\\"x\\\"\\n\\nArabic: 11\\nRoman: \\\"xi\\\"\\n\\nArabic: 15\\nRoman: \\\"xv\\\"\\n\\nArabic: 19\\nRoman: \\\"xix\\\"\\n\\nArabic: 40\\nRoman: \\\"xl\\\"   (x and lowercase L)\\n\\nArabic: 50\\nRoman: \\\"l\\\"    (lowercase L)\\n\\nArabic: 90\\nRoman: \\\"xc\\\"\\n\\nArabic: 100\\nRoman: \\\"c\\\"\\n\\nArabic: 400\\nRoman: \\\"cd\\\"\\n\\nArabic: 500\\nRoman: \\\"d\\\"\\n\\nArabic: 900\\nRoman: \\\"cm\\\"\\n\\nArabic: 1000\\nRoman: \\\"m\\\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}, \"run_tests_output\"=>{:content=>\"Loaded suite test_roman\\nStarted\\n.\\nFinished in 0.000255 seconds.\\n\\n1 tests, 1 assertions, 0 failures, 0 errors\\n\"}}, :language=>\"ruby\", :max_run_tests_duration=>10, :unit_test_framework=>\"test_unit\", :hidden_files=>{\"kata.sh\"=>{:permissions=>493}}}", "roman.rb"=>"class Roman\n\n  def initialize(value)\n    @value = value\n  end\n\n  def to_s\n    \"i\"\n  end\n\nend\n", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"Loaded suite test_roman\nStarted\n.\nFinished in 0.000325 seconds.\n\n1 tests, 1 assertions, 0 failures, 0 errors\n", "avatar"=>"Koalas", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "test_roman.rb"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"i\", Roman.new(1).to_s)\n  end\n\nend\n\n", "kata_id"=>"11", "instructions"=>"Your task is to convert numbers from arabic form to roman form.\nSome examples:\n\nArabic: 1\nRoman: \"i\"\n\nArabic: 2\nRoman: \"ii\"\n\nArabic: 3\nRoman: \"iii\"\n\nArabic: 4\nRoman: \"iv\"\n\nArabic: 5\nRoman: \"v\"\n\nArabic: 6\nRoman: \"vi\"\n\nArabic: 7\nRoman: \"vii\"\n\nArabic: 8\nRoman: \"viii\"\n\nArabic: 9\nRoman: \"ix\"\n\nArabic: 10\nRoman: \"x\"\n\nArabic: 11\nRoman: \"xi\"\n\nArabic: 15\nRoman: \"xv\"\n\nArabic: 19\nRoman: \"xix\"\n\nArabic: 40\nRoman: \"xl\"   (x and lowercase L)\n\nArabic: 50\nRoman: \"l\"    (lowercase L)\n\nArabic: 90\nRoman: \"xc\"\n\nArabic: 100\nRoman: \"c\"\n\nArabic: 400\nRoman: \"cd\"\n\nArabic: 500\nRoman: \"d\"\n\nArabic: 900\nRoman: \"cm\"\n\nArabic: 1000\nRoman: \"m\"\n\n\n\n\n\n\n\n\n\n\n\n\n"}
Rendering kata/run_tests
Completed in 1158ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Koalas&kata_id=11]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 17:01:04) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"roman.rb\"=>{:content=>\"class Roman\\n\\n  def initialize(value)\\n    @value = value\\n  end\\n\\n  def to_s\\n    \\\"i\\\"\\n  end\\n\\nend\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"test_roman.rb\"=>{:content=>\"require 'roman'\\nrequire 'test/unit'\\n\\nclass TestRoman < Test::Unit::TestCase\\n\\n  def test_simple\\n    assert_equal(\\\"i\\\", Roman.new(1).to_s)\\n  end\\n\\nend\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to convert numbers from arabic form to roman form.\\nSome examples:\\n\\nArabic: 1\\nRoman: \\\"i\\\"\\n\\nArabic: 2\\nRoman: \\\"ii\\\"\\n\\nArabic: 3\\nRoman: \\\"iii\\\"\\n\\nArabic: 4\\nRoman: \\\"iv\\\"\\n\\nArabic: 5\\nRoman: \\\"v\\\"\\n\\nArabic: 6\\nRoman: \\\"vi\\\"\\n\\nArabic: 7\\nRoman: \\\"vii\\\"\\n\\nArabic: 8\\nRoman: \\\"viii\\\"\\n\\nArabic: 9\\nRoman: \\\"ix\\\"\\n\\nArabic: 10\\nRoman: \\\"x\\\"\\n\\nArabic: 11\\nRoman: \\\"xi\\\"\\n\\nArabic: 15\\nRoman: \\\"xv\\\"\\n\\nArabic: 19\\nRoman: \\\"xix\\\"\\n\\nArabic: 40\\nRoman: \\\"xl\\\"   (x and lowercase L)\\n\\nArabic: 50\\nRoman: \\\"l\\\"    (lowercase L)\\n\\nArabic: 90\\nRoman: \\\"xc\\\"\\n\\nArabic: 100\\nRoman: \\\"c\\\"\\n\\nArabic: 400\\nRoman: \\\"cd\\\"\\n\\nArabic: 500\\nRoman: \\\"d\\\"\\n\\nArabic: 900\\nRoman: \\\"cm\\\"\\n\\nArabic: 1000\\nRoman: \\\"m\\\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}, \"run_tests_output\"=>{:content=>\"Loaded suite test_roman\\nStarted\\n.\\nFinished in 0.000255 seconds.\\n\\n1 tests, 1 assertions, 0 failures, 0 errors\\n\"}}, :language=>\"ruby\", :max_run_tests_duration=>10, :unit_test_framework=>\"test_unit\", :hidden_files=>{\"kata.sh\"=>{:permissions=>493}}}", "roman.rb"=>"class Roman\n\n  def initialize(value)\n    @value = value\n  end\n\n  def to_s\n    \"i\"\n  end\n\nend\n", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"Loaded suite test_roman\nStarted\n.\nFinished in 0.000228 seconds.\n\n1 tests, 1 assertions, 0 failures, 0 errors\n", "avatar"=>"Koalas", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "test_roman.rb"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"i\", Roman.new(1).to_s)\n  end\n\nend\n\n", "kata_id"=>"11", "instructions"=>"Your task is to convert numbers from arabic form to roman form.\nSome examples:\n\nArabic: 1\nRoman: \"i\"\n\nArabic: 2\nRoman: \"ii\"\n\nArabic: 3\nRoman: \"iii\"\n\nArabic: 4\nRoman: \"iv\"\n\nArabic: 5\nRoman: \"v\"\n\nArabic: 6\nRoman: \"vi\"\n\nArabic: 7\nRoman: \"vii\"\n\nArabic: 8\nRoman: \"viii\"\n\nArabic: 9\nRoman: \"ix\"\n\nArabic: 10\nRoman: \"x\"\n\nArabic: 11\nRoman: \"xi\"\n\nArabic: 15\nRoman: \"xv\"\n\nArabic: 19\nRoman: \"xix\"\n\nArabic: 40\nRoman: \"xl\"   (x and lowercase L)\n\nArabic: 50\nRoman: \"l\"    (lowercase L)\n\nArabic: 90\nRoman: \"xc\"\n\nArabic: 100\nRoman: \"c\"\n\nArabic: 400\nRoman: \"cd\"\n\nArabic: 500\nRoman: \"d\"\n\nArabic: 900\nRoman: \"cm\"\n\nArabic: 1000\nRoman: \"m\"\n\n\n\n\n\n\n\n\n\n\n\n\n"}
Rendering kata/run_tests
Completed in 1128ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Koalas&kata_id=11]


Processing KataController#run_tests (for 127.0.0.1 at 2010-01-12 17:01:12) [POST]
  Parameters: {"commit"=>"run-tests>", "manifest.rb_div"=>"{:visible_files=>{\"roman.rb\"=>{:content=>\"class Roman\\n\\n  def initialize(value)\\n    @value = value\\n  end\\n\\n  def to_s\\n    \\\"i\\\"\\n  end\\n\\nend\\n\"}, \"notes.txt\"=>{:content=>\"Welcome to the game. \\n\\nPlease remember \\n  o) we are not, repeat not, producing software to sell!\\n  o) the sole aim of the game is to practice\\n\\nPracticing means\\n  o) doing something just beyond your current ability\\n  o) going slow, not rushing\\n  o) analyzing your performance during the practice\\n  o) analysing your performance after the practice\\n  o) repeating the practice\\n\\nDuring the game please write notes in this file only.\\n\\n\"}, \"test_roman.rb\"=>{:content=>\"require 'roman'\\nrequire 'test/unit'\\n\\nclass TestRoman < Test::Unit::TestCase\\n\\n  def test_simple\\n    assert_equal(\\\"i\\\", Roman.new(1).to_s)\\n  end\\n\\nend\\n\\n\"}, \"instructions\"=>{:content=>\"Your task is to convert numbers from arabic form to roman form.\\nSome examples:\\n\\nArabic: 1\\nRoman: \\\"i\\\"\\n\\nArabic: 2\\nRoman: \\\"ii\\\"\\n\\nArabic: 3\\nRoman: \\\"iii\\\"\\n\\nArabic: 4\\nRoman: \\\"iv\\\"\\n\\nArabic: 5\\nRoman: \\\"v\\\"\\n\\nArabic: 6\\nRoman: \\\"vi\\\"\\n\\nArabic: 7\\nRoman: \\\"vii\\\"\\n\\nArabic: 8\\nRoman: \\\"viii\\\"\\n\\nArabic: 9\\nRoman: \\\"ix\\\"\\n\\nArabic: 10\\nRoman: \\\"x\\\"\\n\\nArabic: 11\\nRoman: \\\"xi\\\"\\n\\nArabic: 15\\nRoman: \\\"xv\\\"\\n\\nArabic: 19\\nRoman: \\\"xix\\\"\\n\\nArabic: 40\\nRoman: \\\"xl\\\"   (x and lowercase L)\\n\\nArabic: 50\\nRoman: \\\"l\\\"    (lowercase L)\\n\\nArabic: 90\\nRoman: \\\"xc\\\"\\n\\nArabic: 100\\nRoman: \\\"c\\\"\\n\\nArabic: 400\\nRoman: \\\"cd\\\"\\n\\nArabic: 500\\nRoman: \\\"d\\\"\\n\\nArabic: 900\\nRoman: \\\"cm\\\"\\n\\nArabic: 1000\\nRoman: \\\"m\\\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}, \"run_tests_output\"=>{:content=>\"Loaded suite test_roman\\nStarted\\n.\\nFinished in 0.000255 seconds.\\n\\n1 tests, 1 assertions, 0 failures, 0 errors\\n\"}}, :language=>\"ruby\", :max_run_tests_duration=>10, :unit_test_framework=>\"test_unit\", :hidden_files=>{\"kata.sh\"=>{:permissions=>493}}}", "roman.rb"=>"class Roman\n\n  def initialize(value)\n    @value = value\n  end\n\n  def to_s\n    \"i\"\n  end\n\nend\n", "authenticity_token"=>"L6nTHYjuvkqYQkCXDeFCnvpxrALPFH2Xm1p/0+QeW8g=", "tabbed_files"=>"Loaded suite test_roman\nStarted\n.\nFinished in 0.000304 seconds.\n\n1 tests, 1 assertions, 0 failures, 0 errors\n", "avatar"=>"Koalas", "notes.txt"=>"Welcome to the game. \n\nPlease remember \n  o) we are not, repeat not, producing software to sell!\n  o) the sole aim of the game is to practice\n\nPracticing means\n  o) doing something just beyond your current ability\n  o) going slow, not rushing\n  o) analyzing your performance during the practice\n  o) analysing your performance after the practice\n  o) repeating the practice\n\nDuring the game please write notes in this file only.\n\n", "test_roman.rb"=>"require 'roman'\nrequire 'test/unit'\n\nclass TestRoman < Test::Unit::TestCase\n\n  def test_simple\n    assert_equal(\"i\", Roman.new(1).to_s)\n  end\n\nend\n\n", "kata_id"=>"11", "instructions"=>"Your task is to convert numbers from arabic form to roman form.\nSome examples:\n\nArabic: 1\nRoman: \"i\"\n\nArabic: 2\nRoman: \"ii\"\n\nArabic: 3\nRoman: \"iii\"\n\nArabic: 4\nRoman: \"iv\"\n\nArabic: 5\nRoman: \"v\"\n\nArabic: 6\nRoman: \"vi\"\n\nArabic: 7\nRoman: \"vii\"\n\nArabic: 8\nRoman: \"viii\"\n\nArabic: 9\nRoman: \"ix\"\n\nArabic: 10\nRoman: \"x\"\n\nArabic: 11\nRoman: \"xi\"\n\nArabic: 15\nRoman: \"xv\"\n\nArabic: 19\nRoman: \"xix\"\n\nArabic: 40\nRoman: \"xl\"   (x and lowercase L)\n\nArabic: 50\nRoman: \"l\"    (lowercase L)\n\nArabic: 90\nRoman: \"xc\"\n\nArabic: 100\nRoman: \"c\"\n\nArabic: 400\nRoman: \"cd\"\n\nArabic: 500\nRoman: \"d\"\n\nArabic: 900\nRoman: \"cm\"\n\nArabic: 1000\nRoman: \"m\"\n\n\n\n\n\n\n\n\n\n\n\n\n"}
Rendering kata/run_tests
Completed in 1113ms (View: 2, DB: 0) | 200 OK [http://localhost/kata/run_tests?avatar=Koalas&kata_id=11]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 17:01:16) [GET]
  Parameters: {"increment"=>"2", "id"=>"11", "avatar"=>"Koalas"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 5ms (View: 5, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/11?avatar=Koalas&increment=2]


Processing KataController#see_all_increments (for 127.0.0.1 at 2010-01-12 17:01:21) [GET]
  Parameters: {"id"=>"11"}
Rendering template within layouts/application
Rendering kata/see_all_increments
Completed in 4ms (View: 4, DB: 0) | 200 OK [http://localhost/kata/see_all_increments/11]


Processing KataController#see_one_increment (for 127.0.0.1 at 2010-01-12 17:01:30) [GET]
  Parameters: {"increment"=>"3", "id"=>"11", "avatar"=>"Koalas"}
Rendering template within layouts/application
Rendering kata/see_one_increment
Completed in 5ms (View: 4, DB: 0) | 200 OK [http://localhost/kata/see_one_increment/11?avatar=Koalas&increment=3]


Processing DojoController#index (for 127.0.0.1 at 2010-01-12 17:01:42) [GET]
  Parameters: {"id"=>"11"}
Rendering template within layouts/application
Rendering dojo/index
Completed in 4ms (View: 4, DB: 0) | 200 OK [http://localhost/dojo/index/11]
